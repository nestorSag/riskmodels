<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>riskmodels.utils.map_reduce API documentation</title>
<meta name="description" content="This module contains utilities for the execution of multi-core map-reduce operations when using sequencial capacity models from …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>riskmodels.utils.map_reduce</code></h1>
</header>
<section id="section-intro">
<p>This module contains utilities for the execution of multi-core map-reduce operations when using sequencial capacity models from <code><a title="riskmodels.adequacy.capacity_models" href="../adequacy/capacity_models.html">riskmodels.adequacy.capacity_models</a></code>. Classes defined here are the workers of map-reduce computations and act as wrappers for numpy arrays that have been persisted as files and are read in parallel at execution time. These classes are not meant to be instantiated directly, but can be accessed through custom mappers and reducers passed to sequential capacity model instances.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module contains utilities for the execution of multi-core map-reduce operations when using sequencial capacity models from `riskmodels.adequacy.capacity_models`. Classes defined here are the workers of map-reduce computations and act as wrappers for numpy arrays that have been persisted as files and are read in parallel at execution time. These classes are not meant to be instantiated directly, but can be accessed through custom mappers and reducers passed to sequential capacity model instances.

&#34;&#34;&#34;
from __future__ import annotations
import warnings
from abc import ABC, abstractmethod
from pathlib import Path
import copy
import typing as t
from zlib import adler32
from multiprocessing import Pool

import numpy as np
import pandas as pd
from scipy.optimize import bisect

from pydantic import BaseModel as BasePydanticModel

from riskmodels.utils.adequacy_interfaces import BaseCapacityModel, BaseBivariateMonteCarlo



class PersistedTraces(BasePydanticModel):

    &#34;&#34;&#34;Wrapper class for persisted files of simulated traces. This class is not meant to be instantiated directly by the end user.&#34;&#34;&#34;

    traces: np.ndarray

    class Config:
        arbitrary_types_allowed = True

    @classmethod
    def from_file(cls, trace_filepath: str):
        &#34;&#34;&#34;Loads a pickled numpy array that contains conventional generation traces

        Args:
            trace_filepath (str): Path to file
        &#34;&#34;&#34;
        return cls(traces=np.load(trace_filepath, allow_pickle=True))

    def __add__(self, other: float):
        return type(self)(traces=self.samples + other)

    def __mul__(self, other: float):
        return type(self)(traces=self.samples * other)


class UnivariateTraces(BaseCapacityModel, BasePydanticModel):

    &#34;&#34;&#34;Wrapper class for the workers of univariate map-reduce computations; it uses a file containing sequences of conventional generation traces to perform custom computations. Instances of this class are not meant to be instantiated directly by the end user.

    Args:
        gen_filepath (str): folder with conventional generation data
        demand (np.ndarray): demand data
        renewables (np.ndarray): renewables data
        season_length (int): number of timesteps per peak season
    
    &#34;&#34;&#34;

    gen_filepath: str
    demand: np.ndarray
    renewables: np.ndarray
    season_length: int

    class Config:
        arbitrary_types_allowed = True

    # @validator(&#34;season_length&#34;, allow_reuse=True)
    # def season_length_validator(cls, season_length):
    #   if season_length is None:
    #     return len(self.demand)

    @property
    def surplus_trace(self):
        # this return a 2-dimensional array where each row is a trace sample, and each column is a timestep within the trace. A trace may contain multiple concatenated peak seasons
        return PersistedTraces.from_file(self.gen_filepath).traces - (
            self.demand - self.renewables
        )

    @property
    # number of traces in file
    def n_traces(self):
        return len(self.surplus_trace)

    def cdf(self, x: float) -&gt; t.Tuple[float, int]:
        &#34;&#34;&#34;Evaluates the surplus distribution&#39;s CDF. Also returns the number of seasons used to calculate it.

        Args:
            x (float): Description

        Returns:
            t.Tuple[float, int]: A tuple with the estimated value and the number of seasons used to calculate it.
        &#34;&#34;&#34;
        trace = self.surplus_trace
        return np.mean(trace &lt; x)

    def simulate(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for surplus values
        
        Returns:
            np.ndarray: simulated surplus values
        &#34;&#34;&#34;
        return self.surplus_trace

    def simulate_lold(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for energy unserved
        
        Returns:
            np.ndarray: Simulated energy unserved
        &#34;&#34;&#34;
        trace = self.surplus_trace
        n_traces, trace_length = trace.shape
        if trace_length % self.season_length != 0:
            raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
        target_shape = (n_traces*(trace_length//self.season_length), self.season_length) #reshape as (# peak seasons x peak season length)
        return np.sum((np.maximum(0.0, -self.surplus_trace) &gt; 1e-1).reshape(target_shape), axis=1) #1e-1 to avoid problems with numerical rounding errors

    def simulate_eu(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for energy unserved
        
        Returns:
            np.ndarray: Simulated energy unserved
        &#34;&#34;&#34;
        trace = self.surplus_trace
        n_traces, trace_length = trace.shape
        if trace_length % self.season_length != 0:
            raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
        target_shape = (n_traces*(trace_length//self.season_length), self.season_length) #reshape as (# peak seasons x within-peak-season timestamp)
        return np.sum(np.maximum(0.0, -trace).reshape(target_shape), axis=1)

    def lole(self) -&gt; float:
        &#34;&#34;&#34;Evaluates the distribution&#39;s season-wise LOLE. Also returns the number of seasons used to calculate it.

        Returns:
            t.Tuple[float, int]: A tuple with the estimated value and the number of seasons used to calculate it.
        &#34;&#34;&#34;

        # cdf_value, n = self.cdf(0.0)
        # return self.season_length * cdf_value, n
        trace = self.surplus_trace

        n_traces, trace_length = trace.shape
        if trace_length % self.season_length != 0:
            raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
        seasons_per_trace = int(trace_length / self.season_length)
        n_total_seasons = n_traces * seasons_per_trace

        return np.sum(trace &lt; 0) / n_total_seasons

    def eeu(self) -&gt; float:
        &#34;&#34;&#34;Evaluates the distribution&#39;s season-wise expected energy unserved. Also returns the number of seasons used to calculate it.


        Returns:
            t.Tuple[float, int]: A tuple with the estimate value and the number of seasons used to calculate it.
        &#34;&#34;&#34;

        trace = self.surplus_trace

        n_traces, trace_length = trace.shape
        if trace_length % self.season_length != 0:
            raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
        seasons_per_trace = int(trace_length / self.season_length)
        n_total_seasons = n_traces * seasons_per_trace

        return np.sum(np.maximum(0.0, -trace)) / n_total_seasons

    def get_surplus_df(self, shortfalls_only: bool = True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Returns a data frame with time occurrence information of observed surplus values and shortfalls.

        Args:
            shortfalls_only (bool, optional): If True, only shortfall rows are returned

        Returns:
            pd.DataFrame: A data frame with the surplus values, a &#39;season_time&#39; column with the within-season time of occurrence (0,1,...,season_length-1), a &#39;file_id&#39; column that indicates which file was used to compute the value, and a &#39;season&#39; column to indicate which season the value was observed in.

        &#34;&#34;&#34;
        pd.options.mode.chained_assignment = None  # supress false positive warnings

        trace = self.surplus_trace
        df = pd.DataFrame({&#34;surplus&#34;: trace.reshape(-1)})
        df[&#34;time&#34;] = np.arange(len(df))
        # filter by shortfall
        if shortfalls_only:
            df = df.query(&#34;surplus &lt; 0&#34;)
        # add season features
        raw_time = np.array(df[&#34;time&#34;])
        df[&#34;season_time&#34;] = raw_time % self.season_length
        df[&#34;season&#34;] = (raw_time / self.season_length).astype(np.int32)
        df = df.drop(columns=[&#34;time&#34;])
        df[&#34;file_id&#34;] = Path(self.gen_filepath).name

        pd.options.mode.chained_assignment = &#34;warn&#34;  # reset default

        return df


class BivariateTraces(BaseBivariateMonteCarlo):

    &#34;&#34;&#34;Wrapper class for the workers of bivariate map-reduce computations; it uses a file containing sequences of conventional generation traces to perform custom computations. Instances of this class are not meant to be instantiated directly by the end user. This class implements both veto and share policies.

    Args:
        univariate_traces (t.List[UnivariateTraces]): Univariate traces
        policy (str): Either &#39;veto&#39; or &#39;share&#39;
    &#34;&#34;&#34;

    univariate_traces: t.List[UnivariateTraces]
    policy: str

    class Config:
        arbitrary_types_allowed = True

    @property
    def surplus_trace(self):
        &#34;&#34;&#34;This returns the traces as a 3-dimensional array where the axes correspond to area, simulated trace and within-trace time respectively. Each trace may contain multiple concatenated peak seasons&#34;&#34;&#34;
        return np.array([t.surplus_trace for t in self.univariate_traces])

    @property
    # number of traces in each file
    def n_traces(self):
        return self.univariate_traces[0].n_traces

    def get_pre_itc_sample(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a pre-interconnection surplus sample as a two-dimensional array where realisations of different peak seasons have been concatenated for each area (each row is a single time step and each column is an area).

        Returns:
            np.ndarray: Sample
        &#34;&#34;&#34;
        return np.stack(
            [t.surplus_trace.reshape(-1) for t in self.univariate_traces], axis=1
        )

    def itc_flow(self, sample: np.ndarray, itc_cap: int = 1000) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the interconnector flow from a sample of bivariate pre interconnection surplus values. The flow is expressed as flow to area 1 being positive and flow to area 2 being negative.

        Args:
            sample (np.ndarray): Bivariate surplus sample
            itc_cap (int, optional): Interconnection capacity

        Returns:
            np.ndarray

        &#34;&#34;&#34;
        if self.policy == &#34;veto&#34; or itc_cap == 0:
            return super().itc_flow(sample, itc_cap)
        elif self.policy == &#34;share&#34;:
            flow = np.zeros(
                (
                    len(
                        sample,
                    )
                ),
                dtype=np.float32,
            )
            # split individual surplus traces
            s1, s2 = sample[:, 0], sample[:, 1]
            # market-driven shortfall-sharing conditions from a share policy only really kick in under specific conditions; in all other situations, the policy is identical to veto.
            # briefly, this is mostly but not entirely because of interconnector constraints
            share_cond = np.logical_and(s1 + s2 &lt; 0, s1 &lt; itc_cap, s2 &lt; itc_cap)
            # market-driven flows are determined by demand in addition to surpluses; tile demand vector to perform flow calculations
            d1, d2 = (
                self.univariate_traces[0].demand,
                self.univariate_traces[1].demand,
            )  # demand arrays
            if len(d1) != len(d2):
                raise ValueError(&#34;Traces of demand are not the same length.&#34;)

            k = len(sample) / len(d1)  # tiling factor
            if k - int(k) != 0:
                raise ValueError(
                    &#34;Length of surplus samples is not a multiple of demand array length.&#34;
                )
            k = int(k)
            # tile demand ratio directly (demand ratio is used in flow equation below)
            r = np.tile(d1 / (d1 + d2), k)
            # compute share flow when applicable
            flow[share_cond] = np.minimum(
                itc_cap,
                np.maximum(
                    -itc_cap,
                    r[share_cond] * s2[share_cond]
                    - (1 - r[share_cond]) * s1[share_cond],
                ),
            )
            # compute veto flow for all other entries
            flow[np.logical_not(share_cond)] = super().itc_flow(
                sample[np.logical_not(share_cond)], itc_cap
            )
            return flow
        else:
            raise ValueError(&#34;policy must be either &#39;veto&#39; or &#39;share&#39;&#34;)

    def simulate_lold(self, itc_cap: int = 1000) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for loss of load duration
        
        Returns:
            np.ndarray: Simulated loss of load duration
        &#34;&#34;&#34;
        lold_vectors = (np.maximum(0.0, -self.simulate(itc_cap)) &gt; 1e-1).T #avoid numerical rounding errors with offset 1e-1
        n = len(lold_vectors[0])
        if n % self.season_length != 0:
            raise ValueError(&#34;Simulated series length is not a multiple of season length.&#34;)
        return np.stack(
            [v.reshape((n//self.season_length, self.season_length)).sum(axis=1) for v in lold_vectors],
            axis=1)

    def simulate_eu(self, itc_cap: int = 1000) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for energy unserved
        
        Returns:
            np.ndarray: Simulated energy unserved
        &#34;&#34;&#34;
        eu_vectors = np.maximum(0.0, -self.simulate(itc_cap)).T
        n = len(eu_vectors[0])
        if n % self.season_length != 0:
            raise ValueError(&#34;Simulated series length is not a multiple of season length.&#34;)
        return np.stack(
            [v.reshape((n//self.season_length, self.season_length)).sum(axis=1) for v in eu_vectors],
            axis=1)

    def get_surplus_df(
        self, shortfalls_only: bool = True, itc_cap: int = 1000
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Returns a data frame with time occurrence information of observed post-interconnection surplus values and shortfalls.

        Args:
            shortfalls_only (bool, optional): Whether to return only rows corresponding to shortfalls.
            itc_cap (int, optional): Interconnector policy

        Returns:
            pd.DataFrame: A data frame with the surplus values, a &#39;season_time&#39; column with the within-season time of occurrence (0,1,...,season_length-1), a &#39;file_id&#39; column that indicates which file was used to compute the value, and a &#39;season&#39; column to indicate which season the value was observed in.

        &#34;&#34;&#34;
        trace = self.simulate(itc_cap)
        df = pd.DataFrame(trace, columns=[&#34;surplus1&#34;, &#34;surplus2&#34;])
        df[&#34;time&#34;] = np.arange(len(df))
        df[&#34;file_id&#34;] = Path(
            self.univariate_traces[0].gen_filepath
        ).name  # file name is identical for both areas
        # filter by shortfall
        if shortfalls_only:
            df = df.query(&#34;surplus1 &lt; 0 or surplus2 &lt; 0&#34;)
        # add season features
        df[&#34;season_time&#34;] = df[&#34;time&#34;] % self.season_length
        df[&#34;season&#34;] = (df[&#34;time&#34;] / self.season_length).astype(np.int32)
        df = df.drop(columns=[&#34;time&#34;])
        return df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="riskmodels.utils.map_reduce.BivariateTraces"><code class="flex name class">
<span>class <span class="ident">BivariateTraces</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for the workers of bivariate map-reduce computations; it uses a file containing sequences of conventional generation traces to perform custom computations. Instances of this class are not meant to be instantiated directly by the end user. This class implements both veto and share policies.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>univariate_traces</code></strong> :&ensp;<code>t.List[<a title="riskmodels.utils.map_reduce.UnivariateTraces" href="#riskmodels.utils.map_reduce.UnivariateTraces">UnivariateTraces</a>]</code></dt>
<dd>Univariate traces</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>str</code></dt>
<dd>Either 'veto' or 'share'</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BivariateTraces(BaseBivariateMonteCarlo):

    &#34;&#34;&#34;Wrapper class for the workers of bivariate map-reduce computations; it uses a file containing sequences of conventional generation traces to perform custom computations. Instances of this class are not meant to be instantiated directly by the end user. This class implements both veto and share policies.

    Args:
        univariate_traces (t.List[UnivariateTraces]): Univariate traces
        policy (str): Either &#39;veto&#39; or &#39;share&#39;
    &#34;&#34;&#34;

    univariate_traces: t.List[UnivariateTraces]
    policy: str

    class Config:
        arbitrary_types_allowed = True

    @property
    def surplus_trace(self):
        &#34;&#34;&#34;This returns the traces as a 3-dimensional array where the axes correspond to area, simulated trace and within-trace time respectively. Each trace may contain multiple concatenated peak seasons&#34;&#34;&#34;
        return np.array([t.surplus_trace for t in self.univariate_traces])

    @property
    # number of traces in each file
    def n_traces(self):
        return self.univariate_traces[0].n_traces

    def get_pre_itc_sample(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a pre-interconnection surplus sample as a two-dimensional array where realisations of different peak seasons have been concatenated for each area (each row is a single time step and each column is an area).

        Returns:
            np.ndarray: Sample
        &#34;&#34;&#34;
        return np.stack(
            [t.surplus_trace.reshape(-1) for t in self.univariate_traces], axis=1
        )

    def itc_flow(self, sample: np.ndarray, itc_cap: int = 1000) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns the interconnector flow from a sample of bivariate pre interconnection surplus values. The flow is expressed as flow to area 1 being positive and flow to area 2 being negative.

        Args:
            sample (np.ndarray): Bivariate surplus sample
            itc_cap (int, optional): Interconnection capacity

        Returns:
            np.ndarray

        &#34;&#34;&#34;
        if self.policy == &#34;veto&#34; or itc_cap == 0:
            return super().itc_flow(sample, itc_cap)
        elif self.policy == &#34;share&#34;:
            flow = np.zeros(
                (
                    len(
                        sample,
                    )
                ),
                dtype=np.float32,
            )
            # split individual surplus traces
            s1, s2 = sample[:, 0], sample[:, 1]
            # market-driven shortfall-sharing conditions from a share policy only really kick in under specific conditions; in all other situations, the policy is identical to veto.
            # briefly, this is mostly but not entirely because of interconnector constraints
            share_cond = np.logical_and(s1 + s2 &lt; 0, s1 &lt; itc_cap, s2 &lt; itc_cap)
            # market-driven flows are determined by demand in addition to surpluses; tile demand vector to perform flow calculations
            d1, d2 = (
                self.univariate_traces[0].demand,
                self.univariate_traces[1].demand,
            )  # demand arrays
            if len(d1) != len(d2):
                raise ValueError(&#34;Traces of demand are not the same length.&#34;)

            k = len(sample) / len(d1)  # tiling factor
            if k - int(k) != 0:
                raise ValueError(
                    &#34;Length of surplus samples is not a multiple of demand array length.&#34;
                )
            k = int(k)
            # tile demand ratio directly (demand ratio is used in flow equation below)
            r = np.tile(d1 / (d1 + d2), k)
            # compute share flow when applicable
            flow[share_cond] = np.minimum(
                itc_cap,
                np.maximum(
                    -itc_cap,
                    r[share_cond] * s2[share_cond]
                    - (1 - r[share_cond]) * s1[share_cond],
                ),
            )
            # compute veto flow for all other entries
            flow[np.logical_not(share_cond)] = super().itc_flow(
                sample[np.logical_not(share_cond)], itc_cap
            )
            return flow
        else:
            raise ValueError(&#34;policy must be either &#39;veto&#39; or &#39;share&#39;&#34;)

    def simulate_lold(self, itc_cap: int = 1000) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for loss of load duration
        
        Returns:
            np.ndarray: Simulated loss of load duration
        &#34;&#34;&#34;
        lold_vectors = (np.maximum(0.0, -self.simulate(itc_cap)) &gt; 1e-1).T #avoid numerical rounding errors with offset 1e-1
        n = len(lold_vectors[0])
        if n % self.season_length != 0:
            raise ValueError(&#34;Simulated series length is not a multiple of season length.&#34;)
        return np.stack(
            [v.reshape((n//self.season_length, self.season_length)).sum(axis=1) for v in lold_vectors],
            axis=1)

    def simulate_eu(self, itc_cap: int = 1000) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for energy unserved
        
        Returns:
            np.ndarray: Simulated energy unserved
        &#34;&#34;&#34;
        eu_vectors = np.maximum(0.0, -self.simulate(itc_cap)).T
        n = len(eu_vectors[0])
        if n % self.season_length != 0:
            raise ValueError(&#34;Simulated series length is not a multiple of season length.&#34;)
        return np.stack(
            [v.reshape((n//self.season_length, self.season_length)).sum(axis=1) for v in eu_vectors],
            axis=1)

    def get_surplus_df(
        self, shortfalls_only: bool = True, itc_cap: int = 1000
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Returns a data frame with time occurrence information of observed post-interconnection surplus values and shortfalls.

        Args:
            shortfalls_only (bool, optional): Whether to return only rows corresponding to shortfalls.
            itc_cap (int, optional): Interconnector policy

        Returns:
            pd.DataFrame: A data frame with the surplus values, a &#39;season_time&#39; column with the within-season time of occurrence (0,1,...,season_length-1), a &#39;file_id&#39; column that indicates which file was used to compute the value, and a &#39;season&#39; column to indicate which season the value was observed in.

        &#34;&#34;&#34;
        trace = self.simulate(itc_cap)
        df = pd.DataFrame(trace, columns=[&#34;surplus1&#34;, &#34;surplus2&#34;])
        df[&#34;time&#34;] = np.arange(len(df))
        df[&#34;file_id&#34;] = Path(
            self.univariate_traces[0].gen_filepath
        ).name  # file name is identical for both areas
        # filter by shortfall
        if shortfalls_only:
            df = df.query(&#34;surplus1 &lt; 0 or surplus2 &lt; 0&#34;)
        # add season features
        df[&#34;season_time&#34;] = df[&#34;time&#34;] % self.season_length
        df[&#34;season&#34;] = (df[&#34;time&#34;] / self.season_length).astype(np.int32)
        df = df.drop(columns=[&#34;time&#34;])
        return df</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo">BaseBivariateMonteCarlo</a></li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li><a title="riskmodels.utils.adequacy_interfaces.BaseCapacityModel" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseCapacityModel">BaseCapacityModel</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.policy"><code class="name">var <span class="ident">policy</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.univariate_traces"><code class="name">var <span class="ident">univariate_traces</span> : List[<a title="riskmodels.utils.map_reduce.UnivariateTraces" href="#riskmodels.utils.map_reduce.UnivariateTraces">UnivariateTraces</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.n_traces"><code class="name">var <span class="ident">n_traces</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
# number of traces in each file
def n_traces(self):
    return self.univariate_traces[0].n_traces</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.surplus_trace"><code class="name">var <span class="ident">surplus_trace</span></code></dt>
<dd>
<div class="desc"><p>This returns the traces as a 3-dimensional array where the axes correspond to area, simulated trace and within-trace time respectively. Each trace may contain multiple concatenated peak seasons</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def surplus_trace(self):
    &#34;&#34;&#34;This returns the traces as a 3-dimensional array where the axes correspond to area, simulated trace and within-trace time respectively. Each trace may contain multiple concatenated peak seasons&#34;&#34;&#34;
    return np.array([t.surplus_trace for t in self.univariate_traces])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.get_pre_itc_sample"><code class="name flex">
<span>def <span class="ident">get_pre_itc_sample</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a pre-interconnection surplus sample as a two-dimensional array where realisations of different peak seasons have been concatenated for each area (each row is a single time step and each column is an area).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Sample</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pre_itc_sample(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a pre-interconnection surplus sample as a two-dimensional array where realisations of different peak seasons have been concatenated for each area (each row is a single time step and each column is an area).

    Returns:
        np.ndarray: Sample
    &#34;&#34;&#34;
    return np.stack(
        [t.surplus_trace.reshape(-1) for t in self.univariate_traces], axis=1
    )</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.get_surplus_df"><code class="name flex">
<span>def <span class="ident">get_surplus_df</span></span>(<span>self, shortfalls_only: bool = True, itc_cap: int = 1000) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a data frame with time occurrence information of observed post-interconnection surplus values and shortfalls.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shortfalls_only</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to return only rows corresponding to shortfalls.</dd>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnector policy</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A data frame with the surplus values, a 'season_time' column with the within-season time of occurrence (0,1,&hellip;,season_length-1), a 'file_id' column that indicates which file was used to compute the value, and a 'season' column to indicate which season the value was observed in.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_surplus_df(
    self, shortfalls_only: bool = True, itc_cap: int = 1000
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Returns a data frame with time occurrence information of observed post-interconnection surplus values and shortfalls.

    Args:
        shortfalls_only (bool, optional): Whether to return only rows corresponding to shortfalls.
        itc_cap (int, optional): Interconnector policy

    Returns:
        pd.DataFrame: A data frame with the surplus values, a &#39;season_time&#39; column with the within-season time of occurrence (0,1,...,season_length-1), a &#39;file_id&#39; column that indicates which file was used to compute the value, and a &#39;season&#39; column to indicate which season the value was observed in.

    &#34;&#34;&#34;
    trace = self.simulate(itc_cap)
    df = pd.DataFrame(trace, columns=[&#34;surplus1&#34;, &#34;surplus2&#34;])
    df[&#34;time&#34;] = np.arange(len(df))
    df[&#34;file_id&#34;] = Path(
        self.univariate_traces[0].gen_filepath
    ).name  # file name is identical for both areas
    # filter by shortfall
    if shortfalls_only:
        df = df.query(&#34;surplus1 &lt; 0 or surplus2 &lt; 0&#34;)
    # add season features
    df[&#34;season_time&#34;] = df[&#34;time&#34;] % self.season_length
    df[&#34;season&#34;] = (df[&#34;time&#34;] / self.season_length).astype(np.int32)
    df = df.drop(columns=[&#34;time&#34;])
    return df</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.simulate_eu"><code class="name flex">
<span>def <span class="ident">simulate_eu</span></span>(<span>self, itc_cap: int = 1000) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a simulated trace for energy unserved</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Simulated energy unserved</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_eu(self, itc_cap: int = 1000) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a simulated trace for energy unserved
    
    Returns:
        np.ndarray: Simulated energy unserved
    &#34;&#34;&#34;
    eu_vectors = np.maximum(0.0, -self.simulate(itc_cap)).T
    n = len(eu_vectors[0])
    if n % self.season_length != 0:
        raise ValueError(&#34;Simulated series length is not a multiple of season length.&#34;)
    return np.stack(
        [v.reshape((n//self.season_length, self.season_length)).sum(axis=1) for v in eu_vectors],
        axis=1)</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.BivariateTraces.simulate_lold"><code class="name flex">
<span>def <span class="ident">simulate_lold</span></span>(<span>self, itc_cap: int = 1000) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a simulated trace for loss of load duration</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Simulated loss of load duration</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_lold(self, itc_cap: int = 1000) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a simulated trace for loss of load duration
    
    Returns:
        np.ndarray: Simulated loss of load duration
    &#34;&#34;&#34;
    lold_vectors = (np.maximum(0.0, -self.simulate(itc_cap)) &gt; 1e-1).T #avoid numerical rounding errors with offset 1e-1
    n = len(lold_vectors[0])
    if n % self.season_length != 0:
        raise ValueError(&#34;Simulated series length is not a multiple of season length.&#34;)
    return np.stack(
        [v.reshape((n//self.season_length, self.season_length)).sum(axis=1) for v in lold_vectors],
        axis=1)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo">BaseBivariateMonteCarlo</a></b></code>:
<ul class="hlist">
<li><code><a title="riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.cdf" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.cdf">cdf</a></code></li>
<li><code><a title="riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.eeu" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.eeu">eeu</a></code></li>
<li><code><a title="riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.itc_flow" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.itc_flow">itc_flow</a></code></li>
<li><code><a title="riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.lole" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.lole">lole</a></code></li>
<li><code><a title="riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.simulate" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseBivariateMonteCarlo.simulate">simulate</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="riskmodels.utils.map_reduce.PersistedTraces"><code class="flex name class">
<span>class <span class="ident">PersistedTraces</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for persisted files of simulated traces. This class is not meant to be instantiated directly by the end user.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PersistedTraces(BasePydanticModel):

    &#34;&#34;&#34;Wrapper class for persisted files of simulated traces. This class is not meant to be instantiated directly by the end user.&#34;&#34;&#34;

    traces: np.ndarray

    class Config:
        arbitrary_types_allowed = True

    @classmethod
    def from_file(cls, trace_filepath: str):
        &#34;&#34;&#34;Loads a pickled numpy array that contains conventional generation traces

        Args:
            trace_filepath (str): Path to file
        &#34;&#34;&#34;
        return cls(traces=np.load(trace_filepath, allow_pickle=True))

    def __add__(self, other: float):
        return type(self)(traces=self.samples + other)

    def __mul__(self, other: float):
        return type(self)(traces=self.samples * other)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="riskmodels.utils.map_reduce.PersistedTraces.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.utils.map_reduce.PersistedTraces.traces"><code class="name">var <span class="ident">traces</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="riskmodels.utils.map_reduce.PersistedTraces.from_file"><code class="name flex">
<span>def <span class="ident">from_file</span></span>(<span>trace_filepath: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a pickled numpy array that contains conventional generation traces</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>trace_filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_file(cls, trace_filepath: str):
    &#34;&#34;&#34;Loads a pickled numpy array that contains conventional generation traces

    Args:
        trace_filepath (str): Path to file
    &#34;&#34;&#34;
    return cls(traces=np.load(trace_filepath, allow_pickle=True))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces"><code class="flex name class">
<span>class <span class="ident">UnivariateTraces</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class for the workers of univariate map-reduce computations; it uses a file containing sequences of conventional generation traces to perform custom computations. Instances of this class are not meant to be instantiated directly by the end user.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_filepath</code></strong> :&ensp;<code>str</code></dt>
<dd>folder with conventional generation data</dd>
<dt><strong><code>demand</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>demand data</dd>
<dt><strong><code>renewables</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>renewables data</dd>
<dt><strong><code>season_length</code></strong> :&ensp;<code>int</code></dt>
<dd>number of timesteps per peak season</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnivariateTraces(BaseCapacityModel, BasePydanticModel):

    &#34;&#34;&#34;Wrapper class for the workers of univariate map-reduce computations; it uses a file containing sequences of conventional generation traces to perform custom computations. Instances of this class are not meant to be instantiated directly by the end user.

    Args:
        gen_filepath (str): folder with conventional generation data
        demand (np.ndarray): demand data
        renewables (np.ndarray): renewables data
        season_length (int): number of timesteps per peak season
    
    &#34;&#34;&#34;

    gen_filepath: str
    demand: np.ndarray
    renewables: np.ndarray
    season_length: int

    class Config:
        arbitrary_types_allowed = True

    # @validator(&#34;season_length&#34;, allow_reuse=True)
    # def season_length_validator(cls, season_length):
    #   if season_length is None:
    #     return len(self.demand)

    @property
    def surplus_trace(self):
        # this return a 2-dimensional array where each row is a trace sample, and each column is a timestep within the trace. A trace may contain multiple concatenated peak seasons
        return PersistedTraces.from_file(self.gen_filepath).traces - (
            self.demand - self.renewables
        )

    @property
    # number of traces in file
    def n_traces(self):
        return len(self.surplus_trace)

    def cdf(self, x: float) -&gt; t.Tuple[float, int]:
        &#34;&#34;&#34;Evaluates the surplus distribution&#39;s CDF. Also returns the number of seasons used to calculate it.

        Args:
            x (float): Description

        Returns:
            t.Tuple[float, int]: A tuple with the estimated value and the number of seasons used to calculate it.
        &#34;&#34;&#34;
        trace = self.surplus_trace
        return np.mean(trace &lt; x)

    def simulate(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for surplus values
        
        Returns:
            np.ndarray: simulated surplus values
        &#34;&#34;&#34;
        return self.surplus_trace

    def simulate_lold(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for energy unserved
        
        Returns:
            np.ndarray: Simulated energy unserved
        &#34;&#34;&#34;
        trace = self.surplus_trace
        n_traces, trace_length = trace.shape
        if trace_length % self.season_length != 0:
            raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
        target_shape = (n_traces*(trace_length//self.season_length), self.season_length) #reshape as (# peak seasons x peak season length)
        return np.sum((np.maximum(0.0, -self.surplus_trace) &gt; 1e-1).reshape(target_shape), axis=1) #1e-1 to avoid problems with numerical rounding errors

    def simulate_eu(self) -&gt; np.ndarray:
        &#34;&#34;&#34;Returns a simulated trace for energy unserved
        
        Returns:
            np.ndarray: Simulated energy unserved
        &#34;&#34;&#34;
        trace = self.surplus_trace
        n_traces, trace_length = trace.shape
        if trace_length % self.season_length != 0:
            raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
        target_shape = (n_traces*(trace_length//self.season_length), self.season_length) #reshape as (# peak seasons x within-peak-season timestamp)
        return np.sum(np.maximum(0.0, -trace).reshape(target_shape), axis=1)

    def lole(self) -&gt; float:
        &#34;&#34;&#34;Evaluates the distribution&#39;s season-wise LOLE. Also returns the number of seasons used to calculate it.

        Returns:
            t.Tuple[float, int]: A tuple with the estimated value and the number of seasons used to calculate it.
        &#34;&#34;&#34;

        # cdf_value, n = self.cdf(0.0)
        # return self.season_length * cdf_value, n
        trace = self.surplus_trace

        n_traces, trace_length = trace.shape
        if trace_length % self.season_length != 0:
            raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
        seasons_per_trace = int(trace_length / self.season_length)
        n_total_seasons = n_traces * seasons_per_trace

        return np.sum(trace &lt; 0) / n_total_seasons

    def eeu(self) -&gt; float:
        &#34;&#34;&#34;Evaluates the distribution&#39;s season-wise expected energy unserved. Also returns the number of seasons used to calculate it.


        Returns:
            t.Tuple[float, int]: A tuple with the estimate value and the number of seasons used to calculate it.
        &#34;&#34;&#34;

        trace = self.surplus_trace

        n_traces, trace_length = trace.shape
        if trace_length % self.season_length != 0:
            raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
        seasons_per_trace = int(trace_length / self.season_length)
        n_total_seasons = n_traces * seasons_per_trace

        return np.sum(np.maximum(0.0, -trace)) / n_total_seasons

    def get_surplus_df(self, shortfalls_only: bool = True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Returns a data frame with time occurrence information of observed surplus values and shortfalls.

        Args:
            shortfalls_only (bool, optional): If True, only shortfall rows are returned

        Returns:
            pd.DataFrame: A data frame with the surplus values, a &#39;season_time&#39; column with the within-season time of occurrence (0,1,...,season_length-1), a &#39;file_id&#39; column that indicates which file was used to compute the value, and a &#39;season&#39; column to indicate which season the value was observed in.

        &#34;&#34;&#34;
        pd.options.mode.chained_assignment = None  # supress false positive warnings

        trace = self.surplus_trace
        df = pd.DataFrame({&#34;surplus&#34;: trace.reshape(-1)})
        df[&#34;time&#34;] = np.arange(len(df))
        # filter by shortfall
        if shortfalls_only:
            df = df.query(&#34;surplus &lt; 0&#34;)
        # add season features
        raw_time = np.array(df[&#34;time&#34;])
        df[&#34;season_time&#34;] = raw_time % self.season_length
        df[&#34;season&#34;] = (raw_time / self.season_length).astype(np.int32)
        df = df.drop(columns=[&#34;time&#34;])
        df[&#34;file_id&#34;] = Path(self.gen_filepath).name

        pd.options.mode.chained_assignment = &#34;warn&#34;  # reset default

        return df</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="riskmodels.utils.adequacy_interfaces.BaseCapacityModel" href="adequacy_interfaces.html#riskmodels.utils.adequacy_interfaces.BaseCapacityModel">BaseCapacityModel</a></li>
<li>abc.ABC</li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.demand"><code class="name">var <span class="ident">demand</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.gen_filepath"><code class="name">var <span class="ident">gen_filepath</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.renewables"><code class="name">var <span class="ident">renewables</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.season_length"><code class="name">var <span class="ident">season_length</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.n_traces"><code class="name">var <span class="ident">n_traces</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
# number of traces in file
def n_traces(self):
    return len(self.surplus_trace)</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.surplus_trace"><code class="name">var <span class="ident">surplus_trace</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def surplus_trace(self):
    # this return a 2-dimensional array where each row is a trace sample, and each column is a timestep within the trace. A trace may contain multiple concatenated peak seasons
    return PersistedTraces.from_file(self.gen_filepath).traces - (
        self.demand - self.renewables
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, x: float) ‑> Tuple[float, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the surplus distribution's CDF. Also returns the number of seasons used to calculate it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>Description</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>t.Tuple[float, int]</code></dt>
<dd>A tuple with the estimated value and the number of seasons used to calculate it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self, x: float) -&gt; t.Tuple[float, int]:
    &#34;&#34;&#34;Evaluates the surplus distribution&#39;s CDF. Also returns the number of seasons used to calculate it.

    Args:
        x (float): Description

    Returns:
        t.Tuple[float, int]: A tuple with the estimated value and the number of seasons used to calculate it.
    &#34;&#34;&#34;
    trace = self.surplus_trace
    return np.mean(trace &lt; x)</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.eeu"><code class="name flex">
<span>def <span class="ident">eeu</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the distribution's season-wise expected energy unserved. Also returns the number of seasons used to calculate it.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>t.Tuple[float, int]</code></dt>
<dd>A tuple with the estimate value and the number of seasons used to calculate it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eeu(self) -&gt; float:
    &#34;&#34;&#34;Evaluates the distribution&#39;s season-wise expected energy unserved. Also returns the number of seasons used to calculate it.


    Returns:
        t.Tuple[float, int]: A tuple with the estimate value and the number of seasons used to calculate it.
    &#34;&#34;&#34;

    trace = self.surplus_trace

    n_traces, trace_length = trace.shape
    if trace_length % self.season_length != 0:
        raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
    seasons_per_trace = int(trace_length / self.season_length)
    n_total_seasons = n_traces * seasons_per_trace

    return np.sum(np.maximum(0.0, -trace)) / n_total_seasons</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.get_surplus_df"><code class="name flex">
<span>def <span class="ident">get_surplus_df</span></span>(<span>self, shortfalls_only: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a data frame with time occurrence information of observed surplus values and shortfalls.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shortfalls_only</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, only shortfall rows are returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>A data frame with the surplus values, a 'season_time' column with the within-season time of occurrence (0,1,&hellip;,season_length-1), a 'file_id' column that indicates which file was used to compute the value, and a 'season' column to indicate which season the value was observed in.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_surplus_df(self, shortfalls_only: bool = True) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Returns a data frame with time occurrence information of observed surplus values and shortfalls.

    Args:
        shortfalls_only (bool, optional): If True, only shortfall rows are returned

    Returns:
        pd.DataFrame: A data frame with the surplus values, a &#39;season_time&#39; column with the within-season time of occurrence (0,1,...,season_length-1), a &#39;file_id&#39; column that indicates which file was used to compute the value, and a &#39;season&#39; column to indicate which season the value was observed in.

    &#34;&#34;&#34;
    pd.options.mode.chained_assignment = None  # supress false positive warnings

    trace = self.surplus_trace
    df = pd.DataFrame({&#34;surplus&#34;: trace.reshape(-1)})
    df[&#34;time&#34;] = np.arange(len(df))
    # filter by shortfall
    if shortfalls_only:
        df = df.query(&#34;surplus &lt; 0&#34;)
    # add season features
    raw_time = np.array(df[&#34;time&#34;])
    df[&#34;season_time&#34;] = raw_time % self.season_length
    df[&#34;season&#34;] = (raw_time / self.season_length).astype(np.int32)
    df = df.drop(columns=[&#34;time&#34;])
    df[&#34;file_id&#34;] = Path(self.gen_filepath).name

    pd.options.mode.chained_assignment = &#34;warn&#34;  # reset default

    return df</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.lole"><code class="name flex">
<span>def <span class="ident">lole</span></span>(<span>self) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the distribution's season-wise LOLE. Also returns the number of seasons used to calculate it.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>t.Tuple[float, int]</code></dt>
<dd>A tuple with the estimated value and the number of seasons used to calculate it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lole(self) -&gt; float:
    &#34;&#34;&#34;Evaluates the distribution&#39;s season-wise LOLE. Also returns the number of seasons used to calculate it.

    Returns:
        t.Tuple[float, int]: A tuple with the estimated value and the number of seasons used to calculate it.
    &#34;&#34;&#34;

    # cdf_value, n = self.cdf(0.0)
    # return self.season_length * cdf_value, n
    trace = self.surplus_trace

    n_traces, trace_length = trace.shape
    if trace_length % self.season_length != 0:
        raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
    seasons_per_trace = int(trace_length / self.season_length)
    n_total_seasons = n_traces * seasons_per_trace

    return np.sum(trace &lt; 0) / n_total_seasons</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a simulated trace for surplus values</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>simulated surplus values</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a simulated trace for surplus values
    
    Returns:
        np.ndarray: simulated surplus values
    &#34;&#34;&#34;
    return self.surplus_trace</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.simulate_eu"><code class="name flex">
<span>def <span class="ident">simulate_eu</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a simulated trace for energy unserved</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Simulated energy unserved</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_eu(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a simulated trace for energy unserved
    
    Returns:
        np.ndarray: Simulated energy unserved
    &#34;&#34;&#34;
    trace = self.surplus_trace
    n_traces, trace_length = trace.shape
    if trace_length % self.season_length != 0:
        raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
    target_shape = (n_traces*(trace_length//self.season_length), self.season_length) #reshape as (# peak seasons x within-peak-season timestamp)
    return np.sum(np.maximum(0.0, -trace).reshape(target_shape), axis=1)</code></pre>
</details>
</dd>
<dt id="riskmodels.utils.map_reduce.UnivariateTraces.simulate_lold"><code class="name flex">
<span>def <span class="ident">simulate_lold</span></span>(<span>self) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a simulated trace for energy unserved</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Simulated energy unserved</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_lold(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a simulated trace for energy unserved
    
    Returns:
        np.ndarray: Simulated energy unserved
    &#34;&#34;&#34;
    trace = self.surplus_trace
    n_traces, trace_length = trace.shape
    if trace_length % self.season_length != 0:
        raise ValueError(&#34;Trace length is not a multiple of season length.&#34;)
    target_shape = (n_traces*(trace_length//self.season_length), self.season_length) #reshape as (# peak seasons x peak season length)
    return np.sum((np.maximum(0.0, -self.surplus_trace) &gt; 1e-1).reshape(target_shape), axis=1) #1e-1 to avoid problems with numerical rounding errors</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="riskmodels.utils" href="index.html">riskmodels.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="riskmodels.utils.map_reduce.BivariateTraces" href="#riskmodels.utils.map_reduce.BivariateTraces">BivariateTraces</a></code></h4>
<ul class="two-column">
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.Config" href="#riskmodels.utils.map_reduce.BivariateTraces.Config">Config</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.get_pre_itc_sample" href="#riskmodels.utils.map_reduce.BivariateTraces.get_pre_itc_sample">get_pre_itc_sample</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.get_surplus_df" href="#riskmodels.utils.map_reduce.BivariateTraces.get_surplus_df">get_surplus_df</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.n_traces" href="#riskmodels.utils.map_reduce.BivariateTraces.n_traces">n_traces</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.policy" href="#riskmodels.utils.map_reduce.BivariateTraces.policy">policy</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.simulate_eu" href="#riskmodels.utils.map_reduce.BivariateTraces.simulate_eu">simulate_eu</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.simulate_lold" href="#riskmodels.utils.map_reduce.BivariateTraces.simulate_lold">simulate_lold</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.surplus_trace" href="#riskmodels.utils.map_reduce.BivariateTraces.surplus_trace">surplus_trace</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.BivariateTraces.univariate_traces" href="#riskmodels.utils.map_reduce.BivariateTraces.univariate_traces">univariate_traces</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="riskmodels.utils.map_reduce.PersistedTraces" href="#riskmodels.utils.map_reduce.PersistedTraces">PersistedTraces</a></code></h4>
<ul class="">
<li><code><a title="riskmodels.utils.map_reduce.PersistedTraces.Config" href="#riskmodels.utils.map_reduce.PersistedTraces.Config">Config</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.PersistedTraces.from_file" href="#riskmodels.utils.map_reduce.PersistedTraces.from_file">from_file</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.PersistedTraces.traces" href="#riskmodels.utils.map_reduce.PersistedTraces.traces">traces</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="riskmodels.utils.map_reduce.UnivariateTraces" href="#riskmodels.utils.map_reduce.UnivariateTraces">UnivariateTraces</a></code></h4>
<ul class="two-column">
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.Config" href="#riskmodels.utils.map_reduce.UnivariateTraces.Config">Config</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.cdf" href="#riskmodels.utils.map_reduce.UnivariateTraces.cdf">cdf</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.demand" href="#riskmodels.utils.map_reduce.UnivariateTraces.demand">demand</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.eeu" href="#riskmodels.utils.map_reduce.UnivariateTraces.eeu">eeu</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.gen_filepath" href="#riskmodels.utils.map_reduce.UnivariateTraces.gen_filepath">gen_filepath</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.get_surplus_df" href="#riskmodels.utils.map_reduce.UnivariateTraces.get_surplus_df">get_surplus_df</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.lole" href="#riskmodels.utils.map_reduce.UnivariateTraces.lole">lole</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.n_traces" href="#riskmodels.utils.map_reduce.UnivariateTraces.n_traces">n_traces</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.renewables" href="#riskmodels.utils.map_reduce.UnivariateTraces.renewables">renewables</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.season_length" href="#riskmodels.utils.map_reduce.UnivariateTraces.season_length">season_length</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.simulate" href="#riskmodels.utils.map_reduce.UnivariateTraces.simulate">simulate</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.simulate_eu" href="#riskmodels.utils.map_reduce.UnivariateTraces.simulate_eu">simulate_eu</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.simulate_lold" href="#riskmodels.utils.map_reduce.UnivariateTraces.simulate_lold">simulate_lold</a></code></li>
<li><code><a title="riskmodels.utils.map_reduce.UnivariateTraces.surplus_trace" href="#riskmodels.utils.map_reduce.UnivariateTraces.surplus_trace">surplus_trace</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>