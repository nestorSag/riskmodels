<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>riskmodels.powersys.ts.convgen API documentation</title>
<meta name="description" content="This module implements a sequential model for available conventional generation, by representing each generator as a Markov chain whose transition …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>riskmodels.powersys.ts.convgen</code></h1>
</header>
<section id="section-intro">
<p>This module implements a sequential model for available conventional generation, by representing each generator as a Markov chain whose transition probabilities are based on their overall availability and mean time to repair values. Available generation is then the aggregate of all Markov chains at each timestep.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module implements a sequential model for available conventional generation, by representing each generator as a Markov chain whose transition probabilities are based on their overall availability and mean time to repair values. Available generation is then the aggregate of all Markov chains at each timestep.
&#34;&#34;&#34;
from __future__ import annotations
import warnings
import typing as t

import numpy as np
import pandas as pd

from c_sequential_models_api import ffi, lib as C_API

from riskmodels.powersys.iid.convgen import IndependentFleetModel


class MarkovChainGenerationModel(IndependentFleetModel):
    &#34;&#34;&#34;Available conventional generation model in which generators are modelled as Markov chains and are assumed to be independent of each other. The methods `from_generator_df` and `from_generator_file` can be used to instantiate this class when 2-state Markov chains are used (on-off availability for each generating unit without de-rated states), see the cited methods for details. 
    To simulate Markov chain models with a different set of statess (e.g. de-rated states) the class method `simulate_chains` can be used by passing custom `transition_matrices` and `chain_states` arguments along with other required parameters. See the cited function for details.
    &#34;&#34;&#34;

    transition_matrices: np.ndarray
    chain_states: np.ndarray

    def __str__(self):
        max_cap = np.sum([s[0] for s in self.chain_states])
        return f&#34;Markov chain generation model with {len(self.transition_matrices)} generators and {max_cap} maximum capacity&#34;

    @property
    def stationary_distributions(self):
        return np.array(
            [self.get_stationary_dist(mat) for mat in self.transition_matrices]
        )

    @classmethod
    def build_chains(cls, df: pd.DataFrame) -&gt; t.Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Takes a dataframe with generator data (availability and mean time to repair) and returns the corresponding Markov chain states and transition matrices. Here, the availability probability determines the stationary distribution

        Args:
            df (pd.DataFrame): Generator data with columns &#39;availability&#39; and &#39;mttr&#39;

        Returns:
            t.Tuple[np.ndarray, np.ndarray]
        &#34;&#34;&#34;

        def get_transition_matrix(generator_data):
            prob, mttr = generator_data
            alpha = 1 - 1 / mttr
            a11 = 1 - (1 - prob) * (1 - alpha) / prob
            mat = np.array([[a11, 1 - a11], [1 - alpha, alpha]], dtype=np.float32)
            mat = mat / np.sum(mat, axis=1)
            return mat

        states = np.array([np.array([x, 0.0]) for x in df[&#34;capacity&#34;]], dtype=np.int32)
        transition_matrices = np.apply_along_axis(
            get_transition_matrix, 1, np.array(df[[&#34;availability&#34;, &#34;mttr&#34;]])
        )

        return states, transition_matrices

    @classmethod
    def sample_stationary_dists(
        cls, transition_matrices: np.ndarray, chain_states: np.ndarray
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;Sample states from the stationary distribution of transition probability matrices

        Args:
            transition_matrices (np.ndarray): array of transition probability matrices
            chain_states (np.ndarray): two-dimensional array with state vectors for each transition matrix

        Returns:
            np.ndarray: array with sampled state for each transition matrix
        &#34;&#34;&#34;
        sample = []
        for mat, states in zip(transition_matrices, chain_states):
            stationary_dist = cls.get_stationary_dist(mat)
            s = np.random.choice(states, size=1, p=stationary_dist)
            sample.append(s)

        return np.array(sample)

    @classmethod
    def get_stationary_dist(cls, mat: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Compute stationary probability distribution over states for a Markov chain

        Args:
            mat (np.ndarray): transition probability matrix

        Returns:
            np.ndarray: vector with stationary probability values for each state

        &#34;&#34;&#34;
        # from somewhere in stackoverflow

        evals, evecs = np.linalg.eig(mat.T)
        evec1 = evecs[:, np.isclose(evals, 1)]

        # Since np.isclose will return an array, we&#39;ve indexed with an array
        # so we still have our 2nd axis.  Get rid of it, since it&#39;s only size 1.
        if evec1.shape[1] == 0:
            raise Exception(&#34;Some generators might not have a stationary distribution&#34;)
        evec1 = evec1[:, 0]

        stationary = evec1 / evec1.sum()

        # eigs finds complex eigenvalues and eigenvectors, so you&#39;ll want the real part.
        stationary = stationary.real

        return stationary

    @classmethod
    def from_generator_df(cls, df: pd.DataFrame) -&gt; MarkovChainGenerationModel:
        &#34;&#34;&#34;Takes a dataframe object and builds the generation model from it.

        Args:
            df (pd.DataFrame): dataframe with colums &#39;availability&#39; and &#39;capacity&#39;, where the former is the probability that the generating unit is available (i.e. stationary availability probability) and the latter is the unit&#39;s nameplate capacity; in additon, an &#39;mttr&#39; column with estimated mean times to repair per unit should be present. Each row represents an individual generator.

        Returns:
            MarkovChainGenerationModel: fitted model

        &#34;&#34;&#34;

        time_collapsed = super().from_generator_df(df)

        df[&#34;capacity&#34;] = df[&#34;capacity&#34;].astype(
            np.int32
        )  # for consistency between time-collapsed and time-dependent logic

        states, matrices = cls.build_chains(df)

        return cls(
            pdf_values=time_collapsed.pdf_values,
            support=time_collapsed.support,
            data=time_collapsed.data,
            transition_matrices=matrices,
            chain_states=states,
        )

    @classmethod
    def simulate_chains(
        cls,
        size: int,
        trace_length: int,
        transition_matrices: np.ndarray,
        chain_states: np.ndarray,
        initial_state: np.ndarray = None,
        simulate_escape_time: bool = True,
        output_array: np.ndarray = None,
        seed: int = None
    ) -&gt; np.Optional[np.ndarray]:
        &#34;&#34;&#34;Simulate multiple traces in which each one represents the aggregate of multiple Markov chains. This method samples a single large sequential trace and then split it into multiple subtraces; trace endpoints are therefore dependent.
        
        Args:
            size (int): Number of traces to simulate
            trace_length (int): length of individual traces
            transition_matrices (np.ndarray): three-dimensional array containing transition probability matrices for all chains where the first dimension corresponds to generating units and the last two dimensions correspond to transition matrices.
            chain_states (np.ndarray): two-dimensional array with vectors of chain states for all chains where the first dimension corresponds to generating units and the second one to the state set. Note that every generating unit must have the same number of states.
            initial_state (np.ndarray, optional): one-dimensional array with the initial state indices for all chains. The indices must correspond to a row in the transition matrices. If None, initial states are sampled from the stationary distributions of each chain.
            simulate_escape_time (bool, optional): If True, simulate chains through time-of-escape simulations. If false, simulate each timestep individually.
            output_array (np.ndarray, optional): Array where results are to be stored. If not provided, one is created.
            seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
        
        No Longer Returned:
            np.Optional[np.ndarray]: two-dimensional array in which each row represent an individual simulated trace. If an output array is passed as input, None is returned.
        
        
        No Longer Raises:
            ValueError: Description
        
        
        &#34;&#34;&#34;
        n_chains = len(chain_states)
        n_states = len(chain_states[0])

        # set output array
        if output_array is not None:
            if (
                not isinstance(output_array, np.ndarray)
                or len(output_array.shape) != 2
                or output_array.shape != (size, trace_length)
                or output_array.dtype != np.float32
            ):
                raise ValueError(
                    &#34;output_array must be a two-dimensional numpy array with shape (size, trace_length) of type numpy.float32&#34;
                )
            return_output = False
        else:
            output_array = np.ascontiguousarray(
                np.zeros((size, trace_length)), dtype=np.float32
            )
            return_output = True

        # if seed is None:
        #   seed = np.random.randint(low=0,high=2**31-1)
        # else:
        #   np.random.seed(seed) #both numpy and C seeds are the same if provided; this is needed for the initial state which is computed in Python
        seed = np.random.randint(low=0, high=2**20-1) if seed is None else seed
        #print(f&#34;C seed: {seed}&#34;)
        # set initial state array
        if initial_state is None:
            initial_state = cls.sample_stationary_dists(
                transition_matrices, chain_states
            ).reshape(-1)
        else:
            if (
                not isinstance(initial_state, np.ndarray)
                or len(initial_state.shape) != 1
                or len(initial_state) != n_chains
            ):
                # print(initial_state)
                # print(initial_state.shape)
                raise ValueError(
                    &#34;Initial state vector must be a one-dimensional numpy array with as many entries as transition_matrices.&#34;
                )

        if np.any(np.array([len(s) for s in chain_states]) != n_states):
            raise ValueError(&#34;Number of states must be the same for all chains&#34;)

        if np.any(
            np.array([s.shape != (n_states, n_states) for s in transition_matrices])
        ):
            raise ValueError(&#34;Matrices must be square and of the same dimensions&#34;)

        # call C program
        if trace_length &lt;= 1:
            raise ValueError(&#34;Trace length must be an integer larger than 1&#34;)

        # cast as float
        initial_state = np.ascontiguousarray(initial_state).astype(np.float32)
        float_chain_states = chain_states.astype(np.float32)

        C_API.simulate_mc_power_grid_py_interface(
            ffi.cast(&#34;float *&#34;, output_array.ctypes.data),
            ffi.cast(&#34;float *&#34;, transition_matrices.ctypes.data),
            ffi.cast(&#34;float *&#34;, float_chain_states.ctypes.data),
            ffi.cast(&#34;float *&#34;, initial_state.ctypes.data),
            np.int32(n_chains),
            np.int32(size),
            np.int32(
                trace_length - 1
            ),  # initial state is accounted for in trace length
            np.int32(n_states),
            np.int32(seed),
            np.int32(simulate_escape_time),
        )

        if return_output:
            return output_array

    def simulate(self, size: int, seed: int = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Simulate a single trace of sequential observations
        
        Args:
            size (int): Number of samples, or equivalently, trace length.
            seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
        
        Returns:
            np.ndarray
        &#34;&#34;&#34;
        return self.simulate_chains(
            size=1,
            trace_length=size,
            transition_matrices=self.transition_matrices,
            chain_states=self.chain_states,
            initial_state=None,
            simulate_escape_time=True,
            seed=seed
        ).reshape(-1)

    def simulate_seasons(
        self,
        size: int,
        season_length: int,
        seasons_per_trace: int = 1,
        burn_in: int = 100,
        seed: int = None
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;Simulate multiple traces of available conventional generation; each trace can have one or more peak seasons in it, depending on whether streaks of multiple years need to be sampled.
        
        Args:
            size (int): number of traces to sample
            season_length (int): peak season length
            seasons_per_trace (int, optional): Number of seasons per trace. The default is 1.
            burn_in (int, optional): burn-in period between individual peak season traces; this is needed because in order to sample them, a large sequence is generated and subsequently subdivided, thus making trace endpoints correlated if a burn-in period is not allowed.
            seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
        
        No Longer Returned:
            np.ndarray: two-dimensional array where each row represent a sampled peak season of available conventional generation.
        &#34;&#34;&#34;
        total_seasons = size * seasons_per_trace
        augmented_season_length = season_length + burn_in

        output_array = self.simulate_chains(
            size=total_seasons,
            trace_length=augmented_season_length,
            transition_matrices=self.transition_matrices,
            chain_states=self.chain_states,
            initial_state=None,
            simulate_escape_time=True,
            seed=seed
        )

        # drop burn in periods and reshape
        return output_array[:, 0:season_length].reshape(
            (size, season_length * seasons_per_trace)
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel"><code class="flex name class">
<span>class <span class="ident">MarkovChainGenerationModel</span></span>
<span>(</span><span>**data: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Available conventional generation model in which generators are modelled as Markov chains and are assumed to be independent of each other. The methods <code>from_generator_df</code> and <code>from_generator_file</code> can be used to instantiate this class when 2-state Markov chains are used (on-off availability for each generating unit without de-rated states), see the cited methods for details.
To simulate Markov chain models with a different set of statess (e.g. de-rated states) the class method <code>simulate_chains</code> can be used by passing custom <code>transition_matrices</code> and <code>chain_states</code> arguments along with other required parameters. See the cited function for details.</p>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MarkovChainGenerationModel(IndependentFleetModel):
    &#34;&#34;&#34;Available conventional generation model in which generators are modelled as Markov chains and are assumed to be independent of each other. The methods `from_generator_df` and `from_generator_file` can be used to instantiate this class when 2-state Markov chains are used (on-off availability for each generating unit without de-rated states), see the cited methods for details. 
    To simulate Markov chain models with a different set of statess (e.g. de-rated states) the class method `simulate_chains` can be used by passing custom `transition_matrices` and `chain_states` arguments along with other required parameters. See the cited function for details.
    &#34;&#34;&#34;

    transition_matrices: np.ndarray
    chain_states: np.ndarray

    def __str__(self):
        max_cap = np.sum([s[0] for s in self.chain_states])
        return f&#34;Markov chain generation model with {len(self.transition_matrices)} generators and {max_cap} maximum capacity&#34;

    @property
    def stationary_distributions(self):
        return np.array(
            [self.get_stationary_dist(mat) for mat in self.transition_matrices]
        )

    @classmethod
    def build_chains(cls, df: pd.DataFrame) -&gt; t.Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;Takes a dataframe with generator data (availability and mean time to repair) and returns the corresponding Markov chain states and transition matrices. Here, the availability probability determines the stationary distribution

        Args:
            df (pd.DataFrame): Generator data with columns &#39;availability&#39; and &#39;mttr&#39;

        Returns:
            t.Tuple[np.ndarray, np.ndarray]
        &#34;&#34;&#34;

        def get_transition_matrix(generator_data):
            prob, mttr = generator_data
            alpha = 1 - 1 / mttr
            a11 = 1 - (1 - prob) * (1 - alpha) / prob
            mat = np.array([[a11, 1 - a11], [1 - alpha, alpha]], dtype=np.float32)
            mat = mat / np.sum(mat, axis=1)
            return mat

        states = np.array([np.array([x, 0.0]) for x in df[&#34;capacity&#34;]], dtype=np.int32)
        transition_matrices = np.apply_along_axis(
            get_transition_matrix, 1, np.array(df[[&#34;availability&#34;, &#34;mttr&#34;]])
        )

        return states, transition_matrices

    @classmethod
    def sample_stationary_dists(
        cls, transition_matrices: np.ndarray, chain_states: np.ndarray
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;Sample states from the stationary distribution of transition probability matrices

        Args:
            transition_matrices (np.ndarray): array of transition probability matrices
            chain_states (np.ndarray): two-dimensional array with state vectors for each transition matrix

        Returns:
            np.ndarray: array with sampled state for each transition matrix
        &#34;&#34;&#34;
        sample = []
        for mat, states in zip(transition_matrices, chain_states):
            stationary_dist = cls.get_stationary_dist(mat)
            s = np.random.choice(states, size=1, p=stationary_dist)
            sample.append(s)

        return np.array(sample)

    @classmethod
    def get_stationary_dist(cls, mat: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Compute stationary probability distribution over states for a Markov chain

        Args:
            mat (np.ndarray): transition probability matrix

        Returns:
            np.ndarray: vector with stationary probability values for each state

        &#34;&#34;&#34;
        # from somewhere in stackoverflow

        evals, evecs = np.linalg.eig(mat.T)
        evec1 = evecs[:, np.isclose(evals, 1)]

        # Since np.isclose will return an array, we&#39;ve indexed with an array
        # so we still have our 2nd axis.  Get rid of it, since it&#39;s only size 1.
        if evec1.shape[1] == 0:
            raise Exception(&#34;Some generators might not have a stationary distribution&#34;)
        evec1 = evec1[:, 0]

        stationary = evec1 / evec1.sum()

        # eigs finds complex eigenvalues and eigenvectors, so you&#39;ll want the real part.
        stationary = stationary.real

        return stationary

    @classmethod
    def from_generator_df(cls, df: pd.DataFrame) -&gt; MarkovChainGenerationModel:
        &#34;&#34;&#34;Takes a dataframe object and builds the generation model from it.

        Args:
            df (pd.DataFrame): dataframe with colums &#39;availability&#39; and &#39;capacity&#39;, where the former is the probability that the generating unit is available (i.e. stationary availability probability) and the latter is the unit&#39;s nameplate capacity; in additon, an &#39;mttr&#39; column with estimated mean times to repair per unit should be present. Each row represents an individual generator.

        Returns:
            MarkovChainGenerationModel: fitted model

        &#34;&#34;&#34;

        time_collapsed = super().from_generator_df(df)

        df[&#34;capacity&#34;] = df[&#34;capacity&#34;].astype(
            np.int32
        )  # for consistency between time-collapsed and time-dependent logic

        states, matrices = cls.build_chains(df)

        return cls(
            pdf_values=time_collapsed.pdf_values,
            support=time_collapsed.support,
            data=time_collapsed.data,
            transition_matrices=matrices,
            chain_states=states,
        )

    @classmethod
    def simulate_chains(
        cls,
        size: int,
        trace_length: int,
        transition_matrices: np.ndarray,
        chain_states: np.ndarray,
        initial_state: np.ndarray = None,
        simulate_escape_time: bool = True,
        output_array: np.ndarray = None,
        seed: int = None
    ) -&gt; np.Optional[np.ndarray]:
        &#34;&#34;&#34;Simulate multiple traces in which each one represents the aggregate of multiple Markov chains. This method samples a single large sequential trace and then split it into multiple subtraces; trace endpoints are therefore dependent.
        
        Args:
            size (int): Number of traces to simulate
            trace_length (int): length of individual traces
            transition_matrices (np.ndarray): three-dimensional array containing transition probability matrices for all chains where the first dimension corresponds to generating units and the last two dimensions correspond to transition matrices.
            chain_states (np.ndarray): two-dimensional array with vectors of chain states for all chains where the first dimension corresponds to generating units and the second one to the state set. Note that every generating unit must have the same number of states.
            initial_state (np.ndarray, optional): one-dimensional array with the initial state indices for all chains. The indices must correspond to a row in the transition matrices. If None, initial states are sampled from the stationary distributions of each chain.
            simulate_escape_time (bool, optional): If True, simulate chains through time-of-escape simulations. If false, simulate each timestep individually.
            output_array (np.ndarray, optional): Array where results are to be stored. If not provided, one is created.
            seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
        
        No Longer Returned:
            np.Optional[np.ndarray]: two-dimensional array in which each row represent an individual simulated trace. If an output array is passed as input, None is returned.
        
        
        No Longer Raises:
            ValueError: Description
        
        
        &#34;&#34;&#34;
        n_chains = len(chain_states)
        n_states = len(chain_states[0])

        # set output array
        if output_array is not None:
            if (
                not isinstance(output_array, np.ndarray)
                or len(output_array.shape) != 2
                or output_array.shape != (size, trace_length)
                or output_array.dtype != np.float32
            ):
                raise ValueError(
                    &#34;output_array must be a two-dimensional numpy array with shape (size, trace_length) of type numpy.float32&#34;
                )
            return_output = False
        else:
            output_array = np.ascontiguousarray(
                np.zeros((size, trace_length)), dtype=np.float32
            )
            return_output = True

        # if seed is None:
        #   seed = np.random.randint(low=0,high=2**31-1)
        # else:
        #   np.random.seed(seed) #both numpy and C seeds are the same if provided; this is needed for the initial state which is computed in Python
        seed = np.random.randint(low=0, high=2**20-1) if seed is None else seed
        #print(f&#34;C seed: {seed}&#34;)
        # set initial state array
        if initial_state is None:
            initial_state = cls.sample_stationary_dists(
                transition_matrices, chain_states
            ).reshape(-1)
        else:
            if (
                not isinstance(initial_state, np.ndarray)
                or len(initial_state.shape) != 1
                or len(initial_state) != n_chains
            ):
                # print(initial_state)
                # print(initial_state.shape)
                raise ValueError(
                    &#34;Initial state vector must be a one-dimensional numpy array with as many entries as transition_matrices.&#34;
                )

        if np.any(np.array([len(s) for s in chain_states]) != n_states):
            raise ValueError(&#34;Number of states must be the same for all chains&#34;)

        if np.any(
            np.array([s.shape != (n_states, n_states) for s in transition_matrices])
        ):
            raise ValueError(&#34;Matrices must be square and of the same dimensions&#34;)

        # call C program
        if trace_length &lt;= 1:
            raise ValueError(&#34;Trace length must be an integer larger than 1&#34;)

        # cast as float
        initial_state = np.ascontiguousarray(initial_state).astype(np.float32)
        float_chain_states = chain_states.astype(np.float32)

        C_API.simulate_mc_power_grid_py_interface(
            ffi.cast(&#34;float *&#34;, output_array.ctypes.data),
            ffi.cast(&#34;float *&#34;, transition_matrices.ctypes.data),
            ffi.cast(&#34;float *&#34;, float_chain_states.ctypes.data),
            ffi.cast(&#34;float *&#34;, initial_state.ctypes.data),
            np.int32(n_chains),
            np.int32(size),
            np.int32(
                trace_length - 1
            ),  # initial state is accounted for in trace length
            np.int32(n_states),
            np.int32(seed),
            np.int32(simulate_escape_time),
        )

        if return_output:
            return output_array

    def simulate(self, size: int, seed: int = None) -&gt; np.ndarray:
        &#34;&#34;&#34;Simulate a single trace of sequential observations
        
        Args:
            size (int): Number of samples, or equivalently, trace length.
            seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
        
        Returns:
            np.ndarray
        &#34;&#34;&#34;
        return self.simulate_chains(
            size=1,
            trace_length=size,
            transition_matrices=self.transition_matrices,
            chain_states=self.chain_states,
            initial_state=None,
            simulate_escape_time=True,
            seed=seed
        ).reshape(-1)

    def simulate_seasons(
        self,
        size: int,
        season_length: int,
        seasons_per_trace: int = 1,
        burn_in: int = 100,
        seed: int = None
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;Simulate multiple traces of available conventional generation; each trace can have one or more peak seasons in it, depending on whether streaks of multiple years need to be sampled.
        
        Args:
            size (int): number of traces to sample
            season_length (int): peak season length
            seasons_per_trace (int, optional): Number of seasons per trace. The default is 1.
            burn_in (int, optional): burn-in period between individual peak season traces; this is needed because in order to sample them, a large sequence is generated and subsequently subdivided, thus making trace endpoints correlated if a burn-in period is not allowed.
            seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
        
        No Longer Returned:
            np.ndarray: two-dimensional array where each row represent a sampled peak season of available conventional generation.
        &#34;&#34;&#34;
        total_seasons = size * seasons_per_trace
        augmented_season_length = season_length + burn_in

        output_array = self.simulate_chains(
            size=total_seasons,
            trace_length=augmented_season_length,
            transition_matrices=self.transition_matrices,
            chain_states=self.chain_states,
            initial_state=None,
            simulate_escape_time=True,
            seed=seed
        )

        # drop burn in periods and reshape
        return output_array[:, 0:season_length].reshape(
            (size, season_length * seasons_per_trace)
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel" href="../iid/convgen.html#riskmodels.powersys.iid.convgen.IndependentFleetModel">IndependentFleetModel</a></li>
<li><a title="riskmodels.univariate.Binned" href="../../univariate.html#riskmodels.univariate.Binned">Binned</a></li>
<li><a title="riskmodels.univariate.Empirical" href="../../univariate.html#riskmodels.univariate.Empirical">Empirical</a></li>
<li><a title="riskmodels.univariate.BaseDistribution" href="../../univariate.html#riskmodels.univariate.BaseDistribution">BaseDistribution</a></li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.chain_states"><code class="name">var <span class="ident">chain_states</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.transition_matrices"><code class="name">var <span class="ident">transition_matrices</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.build_chains"><code class="name flex">
<span>def <span class="ident">build_chains</span></span>(<span>df: pd.DataFrame) ‑> Tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a dataframe with generator data (availability and mean time to repair) and returns the corresponding Markov chain states and transition matrices. Here, the availability probability determines the stationary distribution</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Generator data with columns 'availability' and 'mttr'</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>t.Tuple[np.ndarray, np.ndarray]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_chains(cls, df: pd.DataFrame) -&gt; t.Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;Takes a dataframe with generator data (availability and mean time to repair) and returns the corresponding Markov chain states and transition matrices. Here, the availability probability determines the stationary distribution

    Args:
        df (pd.DataFrame): Generator data with columns &#39;availability&#39; and &#39;mttr&#39;

    Returns:
        t.Tuple[np.ndarray, np.ndarray]
    &#34;&#34;&#34;

    def get_transition_matrix(generator_data):
        prob, mttr = generator_data
        alpha = 1 - 1 / mttr
        a11 = 1 - (1 - prob) * (1 - alpha) / prob
        mat = np.array([[a11, 1 - a11], [1 - alpha, alpha]], dtype=np.float32)
        mat = mat / np.sum(mat, axis=1)
        return mat

    states = np.array([np.array([x, 0.0]) for x in df[&#34;capacity&#34;]], dtype=np.int32)
    transition_matrices = np.apply_along_axis(
        get_transition_matrix, 1, np.array(df[[&#34;availability&#34;, &#34;mttr&#34;]])
    )

    return states, transition_matrices</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.from_generator_df"><code class="name flex">
<span>def <span class="ident">from_generator_df</span></span>(<span>df: pd.DataFrame) ‑> <a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel">MarkovChainGenerationModel</a></span>
</code></dt>
<dd>
<div class="desc"><p>Takes a dataframe object and builds the generation model from it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>dataframe with colums 'availability' and 'capacity', where the former is the probability that the generating unit is available (i.e. stationary availability probability) and the latter is the unit's nameplate capacity; in additon, an 'mttr' column with estimated mean times to repair per unit should be present. Each row represents an individual generator.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel">MarkovChainGenerationModel</a></code></dt>
<dd>fitted model</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_generator_df(cls, df: pd.DataFrame) -&gt; MarkovChainGenerationModel:
    &#34;&#34;&#34;Takes a dataframe object and builds the generation model from it.

    Args:
        df (pd.DataFrame): dataframe with colums &#39;availability&#39; and &#39;capacity&#39;, where the former is the probability that the generating unit is available (i.e. stationary availability probability) and the latter is the unit&#39;s nameplate capacity; in additon, an &#39;mttr&#39; column with estimated mean times to repair per unit should be present. Each row represents an individual generator.

    Returns:
        MarkovChainGenerationModel: fitted model

    &#34;&#34;&#34;

    time_collapsed = super().from_generator_df(df)

    df[&#34;capacity&#34;] = df[&#34;capacity&#34;].astype(
        np.int32
    )  # for consistency between time-collapsed and time-dependent logic

    states, matrices = cls.build_chains(df)

    return cls(
        pdf_values=time_collapsed.pdf_values,
        support=time_collapsed.support,
        data=time_collapsed.data,
        transition_matrices=matrices,
        chain_states=states,
    )</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.get_stationary_dist"><code class="name flex">
<span>def <span class="ident">get_stationary_dist</span></span>(<span>mat: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Compute stationary probability distribution over states for a Markov chain</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mat</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>transition probability matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>vector with stationary probability values for each state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_stationary_dist(cls, mat: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Compute stationary probability distribution over states for a Markov chain

    Args:
        mat (np.ndarray): transition probability matrix

    Returns:
        np.ndarray: vector with stationary probability values for each state

    &#34;&#34;&#34;
    # from somewhere in stackoverflow

    evals, evecs = np.linalg.eig(mat.T)
    evec1 = evecs[:, np.isclose(evals, 1)]

    # Since np.isclose will return an array, we&#39;ve indexed with an array
    # so we still have our 2nd axis.  Get rid of it, since it&#39;s only size 1.
    if evec1.shape[1] == 0:
        raise Exception(&#34;Some generators might not have a stationary distribution&#34;)
    evec1 = evec1[:, 0]

    stationary = evec1 / evec1.sum()

    # eigs finds complex eigenvalues and eigenvectors, so you&#39;ll want the real part.
    stationary = stationary.real

    return stationary</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.sample_stationary_dists"><code class="name flex">
<span>def <span class="ident">sample_stationary_dists</span></span>(<span>transition_matrices: np.ndarray, chain_states: np.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Sample states from the stationary distribution of transition probability matrices</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transition_matrices</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>array of transition probability matrices</dd>
<dt><strong><code>chain_states</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>two-dimensional array with state vectors for each transition matrix</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>array with sampled state for each transition matrix</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def sample_stationary_dists(
    cls, transition_matrices: np.ndarray, chain_states: np.ndarray
) -&gt; np.ndarray:
    &#34;&#34;&#34;Sample states from the stationary distribution of transition probability matrices

    Args:
        transition_matrices (np.ndarray): array of transition probability matrices
        chain_states (np.ndarray): two-dimensional array with state vectors for each transition matrix

    Returns:
        np.ndarray: array with sampled state for each transition matrix
    &#34;&#34;&#34;
    sample = []
    for mat, states in zip(transition_matrices, chain_states):
        stationary_dist = cls.get_stationary_dist(mat)
        s = np.random.choice(states, size=1, p=stationary_dist)
        sample.append(s)

    return np.array(sample)</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate_chains"><code class="name flex">
<span>def <span class="ident">simulate_chains</span></span>(<span>size: int, trace_length: int, transition_matrices: np.ndarray, chain_states: np.ndarray, initial_state: np.ndarray = None, simulate_escape_time: bool = True, output_array: np.ndarray = None, seed: int = None) ‑> np.Optional[np.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate multiple traces in which each one represents the aggregate of multiple Markov chains. This method samples a single large sequential trace and then split it into multiple subtraces; trace endpoints are therefore dependent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of traces to simulate</dd>
<dt><strong><code>trace_length</code></strong> :&ensp;<code>int</code></dt>
<dd>length of individual traces</dd>
<dt><strong><code>transition_matrices</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>three-dimensional array containing transition probability matrices for all chains where the first dimension corresponds to generating units and the last two dimensions correspond to transition matrices.</dd>
<dt><strong><code>chain_states</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>two-dimensional array with vectors of chain states for all chains where the first dimension corresponds to generating units and the second one to the state set. Note that every generating unit must have the same number of states.</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>one-dimensional array with the initial state indices for all chains. The indices must correspond to a row in the transition matrices. If None, initial states are sampled from the stationary distributions of each chain.</dd>
<dt><strong><code>simulate_escape_time</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, simulate chains through time-of-escape simulations. If false, simulate each timestep individually.</dd>
<dt><strong><code>output_array</code></strong> :&ensp;<code>np.ndarray</code>, optional</dt>
<dd>Array where results are to be stored. If not provided, one is created.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Random seed passed to C backend. If not given, numpy's random numbers are used to initialise it.</dd>
</dl>
<p>No Longer Returned:
np.Optional[np.ndarray]: two-dimensional array in which each row represent an individual simulated trace. If an output array is passed as input, None is returned.</p>
<p>No Longer Raises:
ValueError: Description</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def simulate_chains(
    cls,
    size: int,
    trace_length: int,
    transition_matrices: np.ndarray,
    chain_states: np.ndarray,
    initial_state: np.ndarray = None,
    simulate_escape_time: bool = True,
    output_array: np.ndarray = None,
    seed: int = None
) -&gt; np.Optional[np.ndarray]:
    &#34;&#34;&#34;Simulate multiple traces in which each one represents the aggregate of multiple Markov chains. This method samples a single large sequential trace and then split it into multiple subtraces; trace endpoints are therefore dependent.
    
    Args:
        size (int): Number of traces to simulate
        trace_length (int): length of individual traces
        transition_matrices (np.ndarray): three-dimensional array containing transition probability matrices for all chains where the first dimension corresponds to generating units and the last two dimensions correspond to transition matrices.
        chain_states (np.ndarray): two-dimensional array with vectors of chain states for all chains where the first dimension corresponds to generating units and the second one to the state set. Note that every generating unit must have the same number of states.
        initial_state (np.ndarray, optional): one-dimensional array with the initial state indices for all chains. The indices must correspond to a row in the transition matrices. If None, initial states are sampled from the stationary distributions of each chain.
        simulate_escape_time (bool, optional): If True, simulate chains through time-of-escape simulations. If false, simulate each timestep individually.
        output_array (np.ndarray, optional): Array where results are to be stored. If not provided, one is created.
        seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
    
    No Longer Returned:
        np.Optional[np.ndarray]: two-dimensional array in which each row represent an individual simulated trace. If an output array is passed as input, None is returned.
    
    
    No Longer Raises:
        ValueError: Description
    
    
    &#34;&#34;&#34;
    n_chains = len(chain_states)
    n_states = len(chain_states[0])

    # set output array
    if output_array is not None:
        if (
            not isinstance(output_array, np.ndarray)
            or len(output_array.shape) != 2
            or output_array.shape != (size, trace_length)
            or output_array.dtype != np.float32
        ):
            raise ValueError(
                &#34;output_array must be a two-dimensional numpy array with shape (size, trace_length) of type numpy.float32&#34;
            )
        return_output = False
    else:
        output_array = np.ascontiguousarray(
            np.zeros((size, trace_length)), dtype=np.float32
        )
        return_output = True

    # if seed is None:
    #   seed = np.random.randint(low=0,high=2**31-1)
    # else:
    #   np.random.seed(seed) #both numpy and C seeds are the same if provided; this is needed for the initial state which is computed in Python
    seed = np.random.randint(low=0, high=2**20-1) if seed is None else seed
    #print(f&#34;C seed: {seed}&#34;)
    # set initial state array
    if initial_state is None:
        initial_state = cls.sample_stationary_dists(
            transition_matrices, chain_states
        ).reshape(-1)
    else:
        if (
            not isinstance(initial_state, np.ndarray)
            or len(initial_state.shape) != 1
            or len(initial_state) != n_chains
        ):
            # print(initial_state)
            # print(initial_state.shape)
            raise ValueError(
                &#34;Initial state vector must be a one-dimensional numpy array with as many entries as transition_matrices.&#34;
            )

    if np.any(np.array([len(s) for s in chain_states]) != n_states):
        raise ValueError(&#34;Number of states must be the same for all chains&#34;)

    if np.any(
        np.array([s.shape != (n_states, n_states) for s in transition_matrices])
    ):
        raise ValueError(&#34;Matrices must be square and of the same dimensions&#34;)

    # call C program
    if trace_length &lt;= 1:
        raise ValueError(&#34;Trace length must be an integer larger than 1&#34;)

    # cast as float
    initial_state = np.ascontiguousarray(initial_state).astype(np.float32)
    float_chain_states = chain_states.astype(np.float32)

    C_API.simulate_mc_power_grid_py_interface(
        ffi.cast(&#34;float *&#34;, output_array.ctypes.data),
        ffi.cast(&#34;float *&#34;, transition_matrices.ctypes.data),
        ffi.cast(&#34;float *&#34;, float_chain_states.ctypes.data),
        ffi.cast(&#34;float *&#34;, initial_state.ctypes.data),
        np.int32(n_chains),
        np.int32(size),
        np.int32(
            trace_length - 1
        ),  # initial state is accounted for in trace length
        np.int32(n_states),
        np.int32(seed),
        np.int32(simulate_escape_time),
    )

    if return_output:
        return output_array</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.stationary_distributions"><code class="name">var <span class="ident">stationary_distributions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stationary_distributions(self):
    return np.array(
        [self.get_stationary_dist(mat) for mat in self.transition_matrices]
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, size: int, seed: int = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate a single trace of sequential observations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of samples, or equivalently, trace length.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Random seed passed to C backend. If not given, numpy's random numbers are used to initialise it.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, size: int, seed: int = None) -&gt; np.ndarray:
    &#34;&#34;&#34;Simulate a single trace of sequential observations
    
    Args:
        size (int): Number of samples, or equivalently, trace length.
        seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
    
    Returns:
        np.ndarray
    &#34;&#34;&#34;
    return self.simulate_chains(
        size=1,
        trace_length=size,
        transition_matrices=self.transition_matrices,
        chain_states=self.chain_states,
        initial_state=None,
        simulate_escape_time=True,
        seed=seed
    ).reshape(-1)</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate_seasons"><code class="name flex">
<span>def <span class="ident">simulate_seasons</span></span>(<span>self, size: int, season_length: int, seasons_per_trace: int = 1, burn_in: int = 100, seed: int = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate multiple traces of available conventional generation; each trace can have one or more peak seasons in it, depending on whether streaks of multiple years need to be sampled.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>number of traces to sample</dd>
<dt><strong><code>season_length</code></strong> :&ensp;<code>int</code></dt>
<dd>peak season length</dd>
<dt><strong><code>seasons_per_trace</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of seasons per trace. The default is 1.</dd>
<dt><strong><code>burn_in</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>burn-in period between individual peak season traces; this is needed because in order to sample them, a large sequence is generated and subsequently subdivided, thus making trace endpoints correlated if a burn-in period is not allowed.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Random seed passed to C backend. If not given, numpy's random numbers are used to initialise it.</dd>
</dl>
<p>No Longer Returned:
np.ndarray: two-dimensional array where each row represent a sampled peak season of available conventional generation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_seasons(
    self,
    size: int,
    season_length: int,
    seasons_per_trace: int = 1,
    burn_in: int = 100,
    seed: int = None
) -&gt; np.ndarray:
    &#34;&#34;&#34;Simulate multiple traces of available conventional generation; each trace can have one or more peak seasons in it, depending on whether streaks of multiple years need to be sampled.
    
    Args:
        size (int): number of traces to sample
        season_length (int): peak season length
        seasons_per_trace (int, optional): Number of seasons per trace. The default is 1.
        burn_in (int, optional): burn-in period between individual peak season traces; this is needed because in order to sample them, a large sequence is generated and subsequently subdivided, thus making trace endpoints correlated if a burn-in period is not allowed.
        seed (int, optional): Random seed passed to C backend. If not given, numpy&#39;s random numbers are used to initialise it.
    
    No Longer Returned:
        np.ndarray: two-dimensional array where each row represent a sampled peak season of available conventional generation.
    &#34;&#34;&#34;
    total_seasons = size * seasons_per_trace
    augmented_season_length = season_length + burn_in

    output_array = self.simulate_chains(
        size=total_seasons,
        trace_length=augmented_season_length,
        transition_matrices=self.transition_matrices,
        chain_states=self.chain_states,
        initial_state=None,
        simulate_escape_time=True,
        seed=seed
    )

    # drop burn in periods and reshape
    return output_array[:, 0:season_length].reshape(
        (size, season_length * seasons_per_trace)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel" href="../iid/convgen.html#riskmodels.powersys.iid.convgen.IndependentFleetModel">IndependentFleetModel</a></b></code>:
<ul class="hlist">
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.cdf" href="../../univariate.html#riskmodels.univariate.BaseDistribution.cdf">cdf</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.cdf_values" href="../../univariate.html#riskmodels.univariate.Empirical.cdf_values">cdf_values</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.cvar" href="../../univariate.html#riskmodels.univariate.BaseDistribution.cvar">cvar</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.ecdf" href="../../univariate.html#riskmodels.univariate.Empirical.ecdf">ecdf</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.ecdf_inv" href="../../univariate.html#riskmodels.univariate.Empirical.ecdf_inv">ecdf_inv</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.fit_tail_model" href="../../univariate.html#riskmodels.univariate.Empirical.fit_tail_model">fit_tail_model</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.from_data" href="../../univariate.html#riskmodels.univariate.Binned.from_data">from_data</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.from_empirical" href="../../univariate.html#riskmodels.univariate.Binned.from_empirical">from_empirical</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.from_generator_csv_file" href="../iid/convgen.html#riskmodels.powersys.iid.convgen.IndependentFleetModel.from_generator_csv_file">from_generator_csv_file</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.histogram" href="../../univariate.html#riskmodels.univariate.BaseDistribution.histogram">histogram</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.map" href="../../univariate.html#riskmodels.univariate.Empirical.map">map</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.max" href="../../univariate.html#riskmodels.univariate.Empirical.max">max</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.mean" href="../../univariate.html#riskmodels.univariate.BaseDistribution.mean">mean</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.min" href="../../univariate.html#riskmodels.univariate.Empirical.min">min</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.moment" href="../../univariate.html#riskmodels.univariate.Empirical.moment">moment</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.pdf" href="../../univariate.html#riskmodels.univariate.BaseDistribution.pdf">pdf</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.pdf_lookup" href="../../univariate.html#riskmodels.univariate.Empirical.pdf_lookup">pdf_lookup</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.plot" href="../../univariate.html#riskmodels.univariate.BaseDistribution.plot">plot</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.plot_mean_residual_life" href="../../univariate.html#riskmodels.univariate.Empirical.plot_mean_residual_life">plot_mean_residual_life</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.ppf" href="../../univariate.html#riskmodels.univariate.Empirical.ppf">ppf</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.std" href="../../univariate.html#riskmodels.univariate.BaseDistribution.std">std</a></code></li>
<li><code><a title="riskmodels.powersys.iid.convgen.IndependentFleetModel.to_integer" href="../../univariate.html#riskmodels.univariate.Empirical.to_integer">to_integer</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="riskmodels.powersys.ts" href="index.html">riskmodels.powersys.ts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel">MarkovChainGenerationModel</a></code></h4>
<ul class="">
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.build_chains" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.build_chains">build_chains</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.chain_states" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.chain_states">chain_states</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.from_generator_df" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.from_generator_df">from_generator_df</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.get_stationary_dist" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.get_stationary_dist">get_stationary_dist</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.sample_stationary_dists" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.sample_stationary_dists">sample_stationary_dists</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate">simulate</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate_chains" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate_chains">simulate_chains</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate_seasons" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.simulate_seasons">simulate_seasons</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.stationary_distributions" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.stationary_distributions">stationary_distributions</a></code></li>
<li><code><a title="riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.transition_matrices" href="#riskmodels.powersys.ts.convgen.MarkovChainGenerationModel.transition_matrices">transition_matrices</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>