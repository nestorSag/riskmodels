<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>riskmodels.powersys.iid.surplus API documentation</title>
<meta name="description" content="This module implements models to calculate risk metrics relevant to energy procurement for the case of an interconnected 2-area system, specifically â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>riskmodels.powersys.iid.surplus</code></h1>
</header>
<section id="section-intro">
<p>This module implements models to calculate risk metrics relevant to energy procurement for the case of an interconnected 2-area system, specifically loss of load expectation (LOLE) and expected energy unserved (EEU). As these models assume a time-collapsed setting in which serial dependence does not exist, only metrics based on expected values like the above can be validly calculated. Exact calculations for empirical demand and renewable models are available for both veto and share policies (see below), and Monte Carlo estimation for arbitrary net demand models are available for a veto policy only.</p>
<p>In a share policy, power flow through the interconnection is driven by market prices, even in the event of a shortfall; this can create situations in which shortfalls spread to other areas by excessive imports or exports. In a veto policy on the other hand, only spare available generation can flow through the interconnector, and areas never divert generation they are already using somewhere else.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module implements models to calculate risk metrics relevant to energy procurement for the case of an interconnected 2-area system, specifically loss of load expectation (LOLE) and expected energy unserved (EEU). As these models assume a time-collapsed setting in which serial dependence does not exist, only metrics based on expected values like the above can be validly calculated. Exact calculations for empirical demand and renewable models are available for both veto and share policies (see below), and Monte Carlo estimation for arbitrary net demand models are available for a veto policy only.

In a share policy, power flow through the interconnection is driven by market prices, even in the event of a shortfall; this can create situations in which shortfalls spread to other areas by excessive imports or exports. In a veto policy on the other hand, only spare available generation can flow through the interconnector, and areas never divert generation they are already using somewhere else. 
&#34;&#34;&#34;

from __future__ import annotations
import warnings
from abc import ABC, abstractmethod
import copy

from riskmodels.bivariate import Independent, BaseDistribution
import riskmodels.univariate as univar

import numpy as np
import pandas as pd

from c_bivariate_surplus_api import ffi, lib as C_API

from pydantic import BaseModel

class BaseSurplus(ABC):

  @abstractmethod
  def cdf(self):
    pass

  @abstractmethod
  def simulate(self):
    pass

  @abstractmethod
  def lole(self):
    pass

  @abstractmethod
  def eeu(self):
    pass
   

class BaseBivariateMonteCarlo(BaseModel, BaseSurplus):

  &#34;&#34;&#34;Base class for calculating time-collapsed risk indices for bivariate power surplus distributions using Monte Carlo. Implements calculations based on an assumed surplus trace, but crucially leaves unimplemented the method to compute this surplus trace; subclasses inheriting from this one can implement different ways to calculate this, such as simulation from bivariate distribution objects or loading traces from a file in the case of sequential Monte Carlo models. Only veto policies are implemented.
  
  Args:
      season_length (int): Length of individual peak seasons
  &#34;&#34;&#34;

  def __repr__(self):
    return f&#34;Surplus MonteCarlo model of type {self.__class__.__name__}&#34;

  season_length: int  

  def itc_flow(self, sample: np.ndarray, itc_cap: int = 1000) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the interconnector flow from a sample of bivariate pre interconnection surplus values. The flow is expressed as flow to area 1 being positive and flow to area 2 being negative.
    
    Args:
        sample (np.ndarray): Bivariate surplus sample
        itc_cap (int, optional): Interconnection capacity
    
    Returns:
        np.ndarray
    &#34;&#34;&#34;
    flow = np.zeros((len(sample, )), dtype=np.float32)

    if itc_cap == 0:
      return flow

    flow_from_area_1_idx = np.logical_and(sample[:,0] &gt; 0, sample[:,1] &lt; 0)
    flow_to_area_1_idx = np.logical_and(sample[:,0] &lt; 0, sample[:,1] &gt; 0)

    # flows are bounded by interconnection capacity, shortfall size and spare available capacity in each area.
    flow[flow_from_area_1_idx] = -np.minimum(itc_cap, np.minimum(sample[:,0][flow_from_area_1_idx], -sample[:,1][flow_from_area_1_idx]))
    flow[flow_to_area_1_idx] = np.minimum(itc_cap, np.minimum(-sample[:,0][flow_to_area_1_idx], sample[:,1][flow_to_area_1_idx]))

    return flow

  def simulate(self, itc_cap: int = 1000):
    &#34;&#34;&#34;Simulate from post-interconnection surplus distribution
    
    Args:
        itc_cap (int, optional): Interconnection capacity
    
    &#34;&#34;&#34;
    pre_itc_sample = self.get_pre_itc_sample()
    flow = self.itc_flow(pre_itc_sample, itc_cap)
    # add flow to pre itc sample
    pre_itc_sample[:,0] += flow
    pre_itc_sample[:,1] -= flow
    return pre_itc_sample

  def cdf(self, x: np.ndarray, itc_cap: int = 1000):
    &#34;&#34;&#34;Estimate the CDF of bivariate post-interconnection surplus evaluated at x
    
    Args:
        x (np.ndarray): point to be evaluated
        itc_cap (int, optional): interconnection capacity
    
    &#34;&#34;&#34;
    samples = self.simulate(itc_cap)
    u = samples &lt;= x.reshape((1,2)) # componentwise comparison
    v = u.dot(np.ones((2,1))) &gt;= 2 #equals 1 if and only if both components fulfill the above condition
    return np.mean(v) #return empirical CDF estimate

  def lole(self, itc_cap: int = 1000, area: int = 0):
    &#34;&#34;&#34;Calculates loss of load expectation for one of the areas in the system    
    Args:
        itc_cap (int, optional): Interconnection capacity
        area (int, optional): Area index (0 or 1); if area=-1, systemwide lole is returned.

    &#34;&#34;&#34;
    # take as loss of load when shortfalls are at least 0.1MW in size; this induces a negligible amount of bias but solves numerical issues when comparing post-itc surpluses to 0 to flag shortfalls.
    x = np.array([-1e-1,-1e-1], dtype=np.float32)
    if area in [0,1]:
      x[1-area] = np.Inf
      return self.season_length * self.cdf(x, itc_cap)
    elif area == -1:
      return self.season_length * (self.cdf(np.array([np.Inf,0]), itc_cap) + self.cdf(np.array([0,np.Inf]), itc_cap) - self.cdf(np.array([0,0]), itc_cap))
    else:
      raise ValueError(&#34;area must be in [-1,0,1]&#34;)

  def eeu(self, itc_cap: int = 1000, area: int = 0):
    &#34;&#34;&#34;Calculates expected energy unserved for one of the areas in the system
    
    Args:
        itc_cap (int, optional): Interconnection capacity
        area (int, optional): Area index (0 or 1).

    &#34;&#34;&#34;
    samples = self.simulate(itc_cap)
    if area in [0,1]:
      return -self.season_length * np.mean(np.minimum(samples[:,area], 0))
    elif area == -1:
      return -self.season_length * (np.mean(np.minimum(samples[:,0], 0)) + np.mean(np.minimum(samples[:,1], 0)))
    else:
      raise ValueError(&#34;area must be in [-1,0,1]&#34;)

  @abstractmethod
  def get_pre_itc_sample(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a pre-interconnection surplus sample
    
    Returns:
        np.ndarray: Sample
    &#34;&#34;&#34;
    pass



class BivariateMonteCarlo(BaseBivariateMonteCarlo):

  &#34;&#34;&#34;General bivariate power surplus distribution formed by a power generation distribution and a net demand distribution. It calculates risk metrics by simulation and only implements a veto policy between areas, this is, areas will only export spare available capacity. 
  
  Args:
      gen_distribution (BaseDistribution): available conventional generation distribution
      net_demand (BaseDistribution): net demand distribution
      size (BaseDistribution): Sample size for Monte Carlo estimation
      
  &#34;&#34;&#34;

  gen_distribution: BaseDistribution
  net_demand: BaseDistribution
  size: int

  class Config:
    arbitrary_types_allowed = True

  def get_pre_itc_sample(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a pre-interconnection surplus sample by simulating the passed bivariate distributions for available conventional generation and net demand
    
    Returns:
        np.ndarray: Sample
    &#34;&#34;&#34;
    return self.gen_distribution.simulate(self.size) - self.net_demand.simulate(self.size)



class BivariateEmpirical(BaseSurplus):

  &#34;&#34;&#34;Computes statistics for the power surpluses in a 2-area power system with a single interconnector, given the distributions of available conventional generation and data for demand and renewable generation in the two areas; this uses the empirical distributions induced by the data. The interconnector is assumed to always work. This class interfaces to C for performance.
  &#34;&#34;&#34;
  
  def __repr__(self):
    return f&#34;Bivariate empirical surplus model with {len(self.demand_data)} observations&#34;
  def __init__(
    self,
    demand_data: np.ndarray,
    renewables_data: np.ndarray,
    gen_distribution: Independent,
    season_length: int = None):
    &#34;&#34;&#34;
    
    Args:
      demand_data (np.ndarray): Demand data matrix with two columns
      gen_distribution (Independent): A bivariate distribution with independent components, where each component is a univar.Binned instance representing the distribution of available conventional generation for the corresponding area
      renewables_data (np.ndarray): Renewable generation data matrix with two columns
      season_length (int, optional): length of peak season. If None, it is set as the length of demand data
    
    &#34;&#34;&#34;
    warnings.warn(&#34;Coercing data to integer values.&#34;, stacklevel=2)

    self.demand_data = np.ascontiguousarray(demand_data, dtype = np.int32)
    self.renewables_data = np.ascontiguousarray(renewables_data, dtype = np.int32)
    self.net_demand_data = np.ascontiguousarray(self.demand_data - self.renewables_data)

    if not isinstance(gen_distribution.x, univar.Binned) or not isinstance(gen_distribution.y, univar.Binned):
      raise TypeError(&#34;Marginal generation distributions must be instances of Binned (i.e. integer support).&#34;)

    # save hard copy of relevant arrays from generation
    # this is needed because strange things happened when copying arrays directly from the Independent instance. This somehow solves the issue
    self.convgen1 = {
      &#34;min&#34;: gen_distribution.x.min,
      &#34;max&#34;: gen_distribution.x.max,
      &#34;cdf_values&#34;: np.ascontiguousarray(np.copy(gen_distribution.x.cdf_values, order=&#34;C&#34;)),
      &#34;expectation_vals&#34;: np.ascontiguousarray(np.cumsum(gen_distribution.x.support * gen_distribution.x.pdf_values))}

    self.convgen2 = {
      &#34;min&#34;: gen_distribution.y.min,
      &#34;max&#34;: gen_distribution.y.max,
      &#34;cdf_values&#34;: np.ascontiguousarray(np.copy(gen_distribution.y.cdf_values, order = &#34;C&#34;)),
      &#34;expectation_vals&#34;: np.ascontiguousarray(np.cumsum(gen_distribution.y.support * gen_distribution.y.pdf_values))}

    self.gen_distribution = gen_distribution
    self.MARGIN_BOUND = int(np.iinfo(np.int32).max / 2)

    if season_length is None:
      warnings.warn(&#34;Using length of demand data as season length.&#34;, stacklevel=2)
    self.season_length = len(self.demand_data) if season_length is None else season_length

  def cdf(
    self, 
    x: np.ndarray,
    itc_cap: int = 1000, 
    policy: str = &#34;veto&#34;):
    &#34;&#34;&#34;Evaluates the bivariate post-interconnection power surplus distribution&#39;s cumulative distribution function
    
    Args:
        x (np.ndarray): value at which to evaluate the cdf
        itc_cap (int, optional): interconnection capacity
        policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.

    &#34;&#34;&#34;

    # if x is an n x 2 matrix
    if len(x.shape) == 2 and len(x) &gt; 1:
      return np.array([self.cdf(v,itc_cap,policy) for v in x])

    #bound and unbunble component values
    x = np.clip(x,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    x1, x2 = x.reshape(-1)

    #convgen1, convgen2 = self.gen_distribution.x, self.gen_distribution.y
    n = len(self.net_demand_data)

    cdf = 0

    for k in range(n):
      net_demand1, net_demand2 = self.net_demand_data[k]
      demand1, demand2 = self.demand_data[k]
      point_cdf = C_API.cond_bivariate_power_margin_cdf_py_interface(
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
        np.int32(x1),
        np.int32(x2),
        np.int32(net_demand1),
        np.int32(net_demand2),
        np.int32(demand1),
        np.int32(demand2),
        np.int32(itc_cap),
        np.int32(policy == &#34;share&#34;))

      cdf += point_cdf
    
    return cdf/self.season_length

  def system_lolp(
    self,
    itc_cap: int=1000):
    &#34;&#34;&#34;Computes the system-wide post-interconnection loss of load probability. This is, the probability that at least one area will experience a shortfall.
    
    Args:
        itc_cap (int, optional): Interconnector capacity
    
    &#34;&#34;&#34;
    def trapezoid_prob(ulc,c):

      ulc1, ulc2 = ulc
      return C_API.trapezoid_prob_py_interface(
        np.int32(ulc1),
        np.int32(ulc2),
        np.int32(c),
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data))
      
    n = len(self.net_demand_data)
    gen = self.gen_distribution
    lolp = 0
    
    c = itc_cap
    for k in range(n):
      net_demand1, net_demand2 = self.net_demand_data[k]
      # system-wide lolp does not depend on the policy
      point_lolp = gen.cdf(np.array([net_demand1-c-1,np.Inf])) + gen.cdf(np.array([np.Inf,net_demand2-c-1])) - gen.cdf(np.array([net_demand1+c,net_demand2-c-1])) + trapezoid_prob((net_demand1-c-1,net_demand2+c),2*c)
      lolp += point_lolp

    return lolp/self.season_length


  def lole(
    self,
    itc_cap: int = 1000,
    policy: str = &#34;veto&#34;,
    area: int=0):
    &#34;&#34;&#34;Computes the post-interconnection loss of load expectation.
    
    Args:
        itc_cap (int, optional): interconnection capacity
        policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.
        area (int, optional): Area for which to evaluate LOLE; if area=-1, system-wide lole is returned
    &#34;&#34;&#34;
    if area == -1:
      return len(self.net_demand_data) * self.system_lolp(itc_cap)

    x = np.array([np.Inf,np.Inf])
    x[area] = -1
    #m = (-1,np.Inf)
    lolp = self.cdf(
      x=x, 
      itc_cap=itc_cap,
      policy=policy) 
    
    return self.season_length * lolp


  def swap_axes(self):
    &#34;&#34;&#34;Utility method to flip components in bivariate distribution objects
    &#34;&#34;&#34;
    self.demand_data = np.flip(self.demand_data,axis=1)
    self.renewables_data = np.flip(self.renewables_data,axis=1)
    self.net_demand_data = np.flip(self.net_demand_data,axis=1)
    
    aux = copy.deepcopy(self.convgen1)
    self.convgen1 = copy.deepcopy(self.convgen2)
    self.convgen2 = aux

    self.gen_distribution = Independent(x=self.gen_distribution.y, y=self.gen_distribution.x)
    
  def eeu(
    self,
    itc_cap: int = 1000,
    policy: str = &#34;veto&#34;,
    area: int=0):
    &#34;&#34;&#34;Computes the post-interconnection expected energy unserved.
    
    Args:
        itc_cap (int, optional): interconnection capacity
        policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.
        area (int, optional): Area for which to evaluate eeu; if area=-1, systemwide eeu is returned
    &#34;&#34;&#34;
    
    if area == -1:
      return self.eeu(itc_cap, policy,0) + self.eeu(itc_cap, policy, 1)

    if area == 1:
      self.swap_axes()
    
    n = len(self.net_demand_data)
    eeu = 0

    for k in range(n):
      #print(i)
      net_demand1, net_demand2 = self.net_demand_data[k]
      d1, d2 = self.demand_data[k]
      if policy == &#34;share&#34;:
        point_EPU = C_API.cond_eeu_share_py_interface(
          np.int32(d1),
          np.int32(d2),
          np.int32(net_demand1),
          np.int32(net_demand2),
          np.int32(itc_cap),
          np.int32(self.convgen1[&#34;min&#34;]),
          np.int32(self.convgen2[&#34;min&#34;]),
          np.int32(self.convgen1[&#34;max&#34;]),
          np.int32(self.convgen2[&#34;max&#34;]),
          ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
          ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
          ffi.cast(&#34;double *&#34;,self.convgen1[&#34;expectation_vals&#34;].ctypes.data))
      elif policy == &#34;veto&#34;:
        point_EPU = C_API.cond_eeu_veto_py_interface(
          np.int32(net_demand1),
          np.int32(net_demand2),
          np.int32(itc_cap),
          np.int32(self.convgen1[&#34;min&#34;]),
          np.int32(self.convgen2[&#34;min&#34;]),
          np.int32(self.convgen1[&#34;max&#34;]),
          np.int32(self.convgen2[&#34;max&#34;]),
          ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
          ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
          ffi.cast(&#34;double *&#34;,self.convgen1[&#34;expectation_vals&#34;].ctypes.data))
      else:
        raise ValueError(f&#34;Policy name ({policy}) not recognised.&#34;)

      eeu += point_EPU

    if area == 1:
      self.swap_axes()

    return eeu

  def get_pointwise_risk(self, x: np.ndarray, itc_cap: int = 1000, policy:str = &#34;veto&#34;):
    &#34;&#34;&#34;Calculates the post-interconnection shortfall probability for each one of the net demand observations
    
    Args:
        x (np.ndarray): point to evaluate CDF at
        itc_cap (int, optional): interconnection capacity
        policy (str): one of &#39;veto&#39; or &#39;share&#39;
    
    &#34;&#34;&#34;
    pointwise_cdfs = np.empty((len(self.demand_data),))
    for k, (demand_row, renewables_row) in enumerate(zip(self.demand_data, self.renewables_data)):
      pointwise_cdfs[k] = type(self)(
        demand_data=demand_row.reshape((1,2)),
        renewables_data=renewables_row.reshape((1,2)),
        gen_distribution=self.gen_distribution).cdf(x=x, itc_cap=itc_cap, policy=policy)

    return pointwise_cdfs

  def simulate(self, size: int, itc_cap: int = 1000, policy = &#34;veto&#34;):
    &#34;&#34;&#34;Simulate the post-interconnection bivariate surplus distribution
    
    Args:
        size (int): Sample size
        itc_cap (int, optional): Interconnector capacity
        policy (str): one of &#39;veto&#39; or &#39;share&#39;
    
    &#34;&#34;&#34;
    return self.simulate_region(size, np.array([np.Inf,np.Inf]), itc_cap, policy, False)

  def simulate_region(
    self,
    size: int,
    upper_bounds: np.ndarray,
    itc_cap: int = 1000,
    policy: str = &#34;veto&#34;,
    shortfall_region: bool = False):

    &#34;&#34;&#34;Simulate post-interconnection bivariate surplus distribution conditioned to a rectangular region bounded above.
    
    Args:
        size (int): Sample size
        upper_bounds (np.ndarray): region&#39;s upper bounds
        itc_cap (int, optional): Interconnector capacity
        policy (str): one of &#39;veto&#39; or &#39;share&#39;
        shortfall_region (bool, optional): If True, upper bounds are ignored and the sampling region becomes the shortfall region, this is, min(S_1, S_2) &lt; 0, or equivalently, that in which at least one area has a shortfall.
    
    &#34;&#34;&#34;
    seed = np.random.randint(low=0,high=1e8)
    upper_bounds = np.clip(upper_bounds,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m1, m2 = upper_bounds
    n = len(self.demand_data)

    simulated = np.ascontiguousarray(np.zeros((size,2)),dtype=np.int32)
    #convgen1, convgen2 = self.gen_distribution.x, self.gen_distribution.y
    ### calculate conditional probability of each historical observation conditioned to the region of interest
    if shortfall_region:
      warnings.warn(&#34;Simulating from shortfall region; ignoring passed upper bounds.&#34;, stacklevel=2)
      pointwise_cdfs = self.get_pointwise_risk(x=np.array([0,np.Inf]),itc_cap=itc_cap,policy=policy) + \
        self.get_pointwise_risk(x=np.array([np.Inf,0]),itc_cap=itc_cap,policy=policy) - \
        self.get_pointwise_risk(x=np.array([0,0]),itc_cap=itc_cap,policy=policy) 
      intersection = False
    else:
      pointwise_cdfs = self.get_pointwise_risk(x=upper_bounds,itc_cap=itc_cap,policy=policy)
      intersection = True
    
    # numerical rounding error sometimes output negative probabilities of the order of 1e-30
    pointwise_cdfs = np.clip(pointwise_cdfs, a_min=0.0, a_max=np.Inf)

    total_prob = np.sum(pointwise_cdfs)
    if total_prob &lt;= 1e-8:
      if fixed_area == 1:
        self.swap_axes()
      raise Exception(f&#34;Region has probability {total_prob}; too small to simulate accurately&#34;)
    else:
      probs = pointwise_cdfs/total_prob
      
      samples_per_row = np.random.multinomial(n=size,pvals=probs,size=1).reshape((len(probs),))
      nonzero_samples = samples_per_row &gt; 0
      ## only pass rows which induce at least one simulated value
      row_weights = np.ascontiguousarray(samples_per_row[nonzero_samples],dtype=np.int32)

      net_demand = np.ascontiguousarray(self.net_demand_data[nonzero_samples,:],dtype=np.int32)

      demand = np.ascontiguousarray(self.demand_data[nonzero_samples,:],dtype=np.int32)

      C_API.region_simulation_py_interface(
        np.int32(size),
        ffi.cast(&#34;int *&#34;,simulated.ctypes.data),
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;int *&#34;,net_demand.ctypes.data),
        ffi.cast(&#34;int *&#34;,demand.ctypes.data),
        ffi.cast(&#34;int *&#34;,row_weights.ctypes.data),
        np.int32(net_demand.shape[0]),
        np.int32(m1),
        np.int32(m2),
        np.int32(itc_cap),
        int(seed),
        int(intersection),
        int(policy == &#34;share&#34;))

      return simulated


  def simulate_conditional(
    self,
    size: int,
    fixed_value: int,
    fixed_area: int,
    itc_cap: int = 1000,
    policy: str = &#34;veto&#34;):
    &#34;&#34;&#34;Simulate post-interconnection surplus distribution conditioned to a value in the other area&#39;s surplus
    
    Args:
        size (int): Sample size
        fixed_value (int): Surplus value conditioned on
        fixed_area (TYPE): Area conditioned on
        itc_cap (int, optional): Interconnector capacity
        policy (str): one of &#39;veto&#39; or &#39;share&#39;
    
    &#34;&#34;&#34;
    seed = np.random.randint(low=0,high=1e8)
    m1 = np.clip(fixed_value,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m2 = self.MARGIN_BOUND

    simulated = np.ascontiguousarray(np.zeros((size,2)),dtype=np.int32)
    
    ### calculate conditional probability of each historical observation given
    ### margin value tuple m

    if fixed_area == 0:
      x = np.array([fixed_value,np.Inf])
      y = x - 1
    else:
      x = np.array([np.Inf, fixed_value])
      y = x - 1

    pointwise_cdfs = self.get_pointwise_risk(x=x,itc_cap=itc_cap,policy=policy) - \
      self.get_pointwise_risk(x=y,itc_cap=itc_cap,policy=policy)

    pointwise_cdfs = np.clip(pointwise_cdfs, a_min=0.0, a_max=np.Inf)
  
    ## rounding errors can make probabilities negative of the order of 1e-60
    total_prob = np.sum(pointwise_cdfs)
    
    if total_prob &lt;= 1e-12:
      raise Exception(f&#34;Region has low probability ({total_prob}); too small to simulate accurately&#34;)
    else:
      probs = pointwise_cdfs/total_prob
      
      samples_per_row = np.random.multinomial(n=size,pvals=probs,size=1).reshape((len(probs),))
      nonzero_samples = samples_per_row &gt; 0
      ## only pass rows which induce at least one simulated value
      row_weights = np.ascontiguousarray(samples_per_row[nonzero_samples],dtype=np.int32)

      if fixed_area == 1:
        self.swap_axes()

      net_demand = np.ascontiguousarray(self.net_demand_data[nonzero_samples,:],dtype=np.int32)

      demand = np.ascontiguousarray(self.demand_data[nonzero_samples,:],dtype=np.int32)

      C_API.conditioned_simulation_py_interface(
        np.int32(size),
        ffi.cast(&#34;int *&#34;,simulated.ctypes.data),
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;int *&#34;,net_demand.ctypes.data),
        ffi.cast(&#34;int *&#34;,demand.ctypes.data),
        ffi.cast(&#34;int *&#34;,row_weights.ctypes.data),
        np.int32(net_demand.shape[0]),
        np.int32(m1),
        np.int32(itc_cap),
        int(seed),
        int(policy == &#34;share&#34;))

      if fixed_area == 1:
        self.swap_axes()

    return simulated[:,1] #first column has variable conditioned on (constant value)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo"><code class="flex name class">
<span>class <span class="ident">BaseBivariateMonteCarlo</span></span>
<span>(</span><span>**data:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for calculating time-collapsed risk indices for bivariate power surplus distributions using Monte Carlo. Implements calculations based on an assumed surplus trace, but crucially leaves unimplemented the method to compute this surplus trace; subclasses inheriting from this one can implement different ways to calculate this, such as simulation from bivariate distribution objects or loading traces from a file in the case of sequential Monte Carlo models. Only veto policies are implemented.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>season_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of individual peak seasons</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseBivariateMonteCarlo(BaseModel, BaseSurplus):

  &#34;&#34;&#34;Base class for calculating time-collapsed risk indices for bivariate power surplus distributions using Monte Carlo. Implements calculations based on an assumed surplus trace, but crucially leaves unimplemented the method to compute this surplus trace; subclasses inheriting from this one can implement different ways to calculate this, such as simulation from bivariate distribution objects or loading traces from a file in the case of sequential Monte Carlo models. Only veto policies are implemented.
  
  Args:
      season_length (int): Length of individual peak seasons
  &#34;&#34;&#34;

  def __repr__(self):
    return f&#34;Surplus MonteCarlo model of type {self.__class__.__name__}&#34;

  season_length: int  

  def itc_flow(self, sample: np.ndarray, itc_cap: int = 1000) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns the interconnector flow from a sample of bivariate pre interconnection surplus values. The flow is expressed as flow to area 1 being positive and flow to area 2 being negative.
    
    Args:
        sample (np.ndarray): Bivariate surplus sample
        itc_cap (int, optional): Interconnection capacity
    
    Returns:
        np.ndarray
    &#34;&#34;&#34;
    flow = np.zeros((len(sample, )), dtype=np.float32)

    if itc_cap == 0:
      return flow

    flow_from_area_1_idx = np.logical_and(sample[:,0] &gt; 0, sample[:,1] &lt; 0)
    flow_to_area_1_idx = np.logical_and(sample[:,0] &lt; 0, sample[:,1] &gt; 0)

    # flows are bounded by interconnection capacity, shortfall size and spare available capacity in each area.
    flow[flow_from_area_1_idx] = -np.minimum(itc_cap, np.minimum(sample[:,0][flow_from_area_1_idx], -sample[:,1][flow_from_area_1_idx]))
    flow[flow_to_area_1_idx] = np.minimum(itc_cap, np.minimum(-sample[:,0][flow_to_area_1_idx], sample[:,1][flow_to_area_1_idx]))

    return flow

  def simulate(self, itc_cap: int = 1000):
    &#34;&#34;&#34;Simulate from post-interconnection surplus distribution
    
    Args:
        itc_cap (int, optional): Interconnection capacity
    
    &#34;&#34;&#34;
    pre_itc_sample = self.get_pre_itc_sample()
    flow = self.itc_flow(pre_itc_sample, itc_cap)
    # add flow to pre itc sample
    pre_itc_sample[:,0] += flow
    pre_itc_sample[:,1] -= flow
    return pre_itc_sample

  def cdf(self, x: np.ndarray, itc_cap: int = 1000):
    &#34;&#34;&#34;Estimate the CDF of bivariate post-interconnection surplus evaluated at x
    
    Args:
        x (np.ndarray): point to be evaluated
        itc_cap (int, optional): interconnection capacity
    
    &#34;&#34;&#34;
    samples = self.simulate(itc_cap)
    u = samples &lt;= x.reshape((1,2)) # componentwise comparison
    v = u.dot(np.ones((2,1))) &gt;= 2 #equals 1 if and only if both components fulfill the above condition
    return np.mean(v) #return empirical CDF estimate

  def lole(self, itc_cap: int = 1000, area: int = 0):
    &#34;&#34;&#34;Calculates loss of load expectation for one of the areas in the system    
    Args:
        itc_cap (int, optional): Interconnection capacity
        area (int, optional): Area index (0 or 1); if area=-1, systemwide lole is returned.

    &#34;&#34;&#34;
    # take as loss of load when shortfalls are at least 0.1MW in size; this induces a negligible amount of bias but solves numerical issues when comparing post-itc surpluses to 0 to flag shortfalls.
    x = np.array([-1e-1,-1e-1], dtype=np.float32)
    if area in [0,1]:
      x[1-area] = np.Inf
      return self.season_length * self.cdf(x, itc_cap)
    elif area == -1:
      return self.season_length * (self.cdf(np.array([np.Inf,0]), itc_cap) + self.cdf(np.array([0,np.Inf]), itc_cap) - self.cdf(np.array([0,0]), itc_cap))
    else:
      raise ValueError(&#34;area must be in [-1,0,1]&#34;)

  def eeu(self, itc_cap: int = 1000, area: int = 0):
    &#34;&#34;&#34;Calculates expected energy unserved for one of the areas in the system
    
    Args:
        itc_cap (int, optional): Interconnection capacity
        area (int, optional): Area index (0 or 1).

    &#34;&#34;&#34;
    samples = self.simulate(itc_cap)
    if area in [0,1]:
      return -self.season_length * np.mean(np.minimum(samples[:,area], 0))
    elif area == -1:
      return -self.season_length * (np.mean(np.minimum(samples[:,0], 0)) + np.mean(np.minimum(samples[:,1], 0)))
    else:
      raise ValueError(&#34;area must be in [-1,0,1]&#34;)

  @abstractmethod
  def get_pre_itc_sample(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a pre-interconnection surplus sample
    
    Returns:
        np.ndarray: Sample
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li><a title="riskmodels.powersys.iid.surplus.BaseSurplus" href="#riskmodels.powersys.iid.surplus.BaseSurplus">BaseSurplus</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="riskmodels.powersys.iid.surplus.BivariateMonteCarlo" href="#riskmodels.powersys.iid.surplus.BivariateMonteCarlo">BivariateMonteCarlo</a></li>
<li><a title="riskmodels.powersys.ts.surplus.BivariateEmpiricalTraces" href="../ts/surplus.html#riskmodels.powersys.ts.surplus.BivariateEmpiricalTraces">BivariateEmpiricalTraces</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.season_length"><code class="name">var <span class="ident">season_length</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, x:Â np.ndarray, itc_cap:Â intÂ =Â 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate the CDF of bivariate post-interconnection surplus evaluated at x</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>point to be evaluated</dd>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>interconnection capacity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self, x: np.ndarray, itc_cap: int = 1000):
  &#34;&#34;&#34;Estimate the CDF of bivariate post-interconnection surplus evaluated at x
  
  Args:
      x (np.ndarray): point to be evaluated
      itc_cap (int, optional): interconnection capacity
  
  &#34;&#34;&#34;
  samples = self.simulate(itc_cap)
  u = samples &lt;= x.reshape((1,2)) # componentwise comparison
  v = u.dot(np.ones((2,1))) &gt;= 2 #equals 1 if and only if both components fulfill the above condition
  return np.mean(v) #return empirical CDF estimate</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.eeu"><code class="name flex">
<span>def <span class="ident">eeu</span></span>(<span>self, itc_cap:Â intÂ =Â 1000, area:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates expected energy unserved for one of the areas in the system</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnection capacity</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Area index (0 or 1).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eeu(self, itc_cap: int = 1000, area: int = 0):
  &#34;&#34;&#34;Calculates expected energy unserved for one of the areas in the system
  
  Args:
      itc_cap (int, optional): Interconnection capacity
      area (int, optional): Area index (0 or 1).

  &#34;&#34;&#34;
  samples = self.simulate(itc_cap)
  if area in [0,1]:
    return -self.season_length * np.mean(np.minimum(samples[:,area], 0))
  elif area == -1:
    return -self.season_length * (np.mean(np.minimum(samples[:,0], 0)) + np.mean(np.minimum(samples[:,1], 0)))
  else:
    raise ValueError(&#34;area must be in [-1,0,1]&#34;)</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.get_pre_itc_sample"><code class="name flex">
<span>def <span class="ident">get_pre_itc_sample</span></span>(<span>self) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a pre-interconnection surplus sample</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Sample</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_pre_itc_sample(self) -&gt; np.ndarray:
  &#34;&#34;&#34;Returns a pre-interconnection surplus sample
  
  Returns:
      np.ndarray: Sample
  &#34;&#34;&#34;
  pass</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.itc_flow"><code class="name flex">
<span>def <span class="ident">itc_flow</span></span>(<span>self, sample:Â np.ndarray, itc_cap:Â intÂ =Â 1000) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the interconnector flow from a sample of bivariate pre interconnection surplus values. The flow is expressed as flow to area 1 being positive and flow to area 2 being negative.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Bivariate surplus sample</dd>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnection capacity</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def itc_flow(self, sample: np.ndarray, itc_cap: int = 1000) -&gt; np.ndarray:
  &#34;&#34;&#34;Returns the interconnector flow from a sample of bivariate pre interconnection surplus values. The flow is expressed as flow to area 1 being positive and flow to area 2 being negative.
  
  Args:
      sample (np.ndarray): Bivariate surplus sample
      itc_cap (int, optional): Interconnection capacity
  
  Returns:
      np.ndarray
  &#34;&#34;&#34;
  flow = np.zeros((len(sample, )), dtype=np.float32)

  if itc_cap == 0:
    return flow

  flow_from_area_1_idx = np.logical_and(sample[:,0] &gt; 0, sample[:,1] &lt; 0)
  flow_to_area_1_idx = np.logical_and(sample[:,0] &lt; 0, sample[:,1] &gt; 0)

  # flows are bounded by interconnection capacity, shortfall size and spare available capacity in each area.
  flow[flow_from_area_1_idx] = -np.minimum(itc_cap, np.minimum(sample[:,0][flow_from_area_1_idx], -sample[:,1][flow_from_area_1_idx]))
  flow[flow_to_area_1_idx] = np.minimum(itc_cap, np.minimum(-sample[:,0][flow_to_area_1_idx], sample[:,1][flow_to_area_1_idx]))

  return flow</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.lole"><code class="name flex">
<span>def <span class="ident">lole</span></span>(<span>self, itc_cap:Â intÂ =Â 1000, area:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates loss of load expectation for one of the areas in the system
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnection capacity</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Area index (0 or 1); if area=-1, systemwide lole is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lole(self, itc_cap: int = 1000, area: int = 0):
  &#34;&#34;&#34;Calculates loss of load expectation for one of the areas in the system    
  Args:
      itc_cap (int, optional): Interconnection capacity
      area (int, optional): Area index (0 or 1); if area=-1, systemwide lole is returned.

  &#34;&#34;&#34;
  # take as loss of load when shortfalls are at least 0.1MW in size; this induces a negligible amount of bias but solves numerical issues when comparing post-itc surpluses to 0 to flag shortfalls.
  x = np.array([-1e-1,-1e-1], dtype=np.float32)
  if area in [0,1]:
    x[1-area] = np.Inf
    return self.season_length * self.cdf(x, itc_cap)
  elif area == -1:
    return self.season_length * (self.cdf(np.array([np.Inf,0]), itc_cap) + self.cdf(np.array([0,np.Inf]), itc_cap) - self.cdf(np.array([0,0]), itc_cap))
  else:
    raise ValueError(&#34;area must be in [-1,0,1]&#34;)</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, itc_cap:Â intÂ =Â 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate from post-interconnection surplus distribution</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnection capacity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, itc_cap: int = 1000):
  &#34;&#34;&#34;Simulate from post-interconnection surplus distribution
  
  Args:
      itc_cap (int, optional): Interconnection capacity
  
  &#34;&#34;&#34;
  pre_itc_sample = self.get_pre_itc_sample()
  flow = self.itc_flow(pre_itc_sample, itc_cap)
  # add flow to pre itc sample
  pre_itc_sample[:,0] += flow
  pre_itc_sample[:,1] -= flow
  return pre_itc_sample</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseSurplus"><code class="flex name class">
<span>class <span class="ident">BaseSurplus</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseSurplus(ABC):

  @abstractmethod
  def cdf(self):
    pass

  @abstractmethod
  def simulate(self):
    pass

  @abstractmethod
  def lole(self):
    pass

  @abstractmethod
  def eeu(self):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo">BaseBivariateMonteCarlo</a></li>
<li><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical">BivariateEmpirical</a></li>
<li><a title="riskmodels.powersys.ts.surplus.UnivariateEmpiricalMapReduce" href="../ts/surplus.html#riskmodels.powersys.ts.surplus.UnivariateEmpiricalMapReduce">UnivariateEmpiricalMapReduce</a></li>
<li><a title="riskmodels.powersys.ts.surplus.UnivariateEmpiricalTraces" href="../ts/surplus.html#riskmodels.powersys.ts.surplus.UnivariateEmpiricalTraces">UnivariateEmpiricalTraces</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="riskmodels.powersys.iid.surplus.BaseSurplus.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def cdf(self):
  pass</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseSurplus.eeu"><code class="name flex">
<span>def <span class="ident">eeu</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def eeu(self):
  pass</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseSurplus.lole"><code class="name flex">
<span>def <span class="ident">lole</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def lole(self):
  pass</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BaseSurplus.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def simulate(self):
  pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical"><code class="flex name class">
<span>class <span class="ident">BivariateEmpirical</span></span>
<span>(</span><span>demand_data:Â np.ndarray, renewables_data:Â np.ndarray, gen_distribution:Â Independent, season_length:Â intÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes statistics for the power surpluses in a 2-area power system with a single interconnector, given the distributions of available conventional generation and data for demand and renewable generation in the two areas; this uses the empirical distributions induced by the data. The interconnector is assumed to always work. This class interfaces to C for performance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>demand_data</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Demand data matrix with two columns</dd>
<dt><strong><code>gen_distribution</code></strong> :&ensp;<code>Independent</code></dt>
<dd>A bivariate distribution with independent components, where each component is a univar.Binned instance representing the distribution of available conventional generation for the corresponding area</dd>
<dt><strong><code>renewables_data</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Renewable generation data matrix with two columns</dd>
<dt><strong><code>season_length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>length of peak season. If None, it is set as the length of demand data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BivariateEmpirical(BaseSurplus):

  &#34;&#34;&#34;Computes statistics for the power surpluses in a 2-area power system with a single interconnector, given the distributions of available conventional generation and data for demand and renewable generation in the two areas; this uses the empirical distributions induced by the data. The interconnector is assumed to always work. This class interfaces to C for performance.
  &#34;&#34;&#34;
  
  def __repr__(self):
    return f&#34;Bivariate empirical surplus model with {len(self.demand_data)} observations&#34;
  def __init__(
    self,
    demand_data: np.ndarray,
    renewables_data: np.ndarray,
    gen_distribution: Independent,
    season_length: int = None):
    &#34;&#34;&#34;
    
    Args:
      demand_data (np.ndarray): Demand data matrix with two columns
      gen_distribution (Independent): A bivariate distribution with independent components, where each component is a univar.Binned instance representing the distribution of available conventional generation for the corresponding area
      renewables_data (np.ndarray): Renewable generation data matrix with two columns
      season_length (int, optional): length of peak season. If None, it is set as the length of demand data
    
    &#34;&#34;&#34;
    warnings.warn(&#34;Coercing data to integer values.&#34;, stacklevel=2)

    self.demand_data = np.ascontiguousarray(demand_data, dtype = np.int32)
    self.renewables_data = np.ascontiguousarray(renewables_data, dtype = np.int32)
    self.net_demand_data = np.ascontiguousarray(self.demand_data - self.renewables_data)

    if not isinstance(gen_distribution.x, univar.Binned) or not isinstance(gen_distribution.y, univar.Binned):
      raise TypeError(&#34;Marginal generation distributions must be instances of Binned (i.e. integer support).&#34;)

    # save hard copy of relevant arrays from generation
    # this is needed because strange things happened when copying arrays directly from the Independent instance. This somehow solves the issue
    self.convgen1 = {
      &#34;min&#34;: gen_distribution.x.min,
      &#34;max&#34;: gen_distribution.x.max,
      &#34;cdf_values&#34;: np.ascontiguousarray(np.copy(gen_distribution.x.cdf_values, order=&#34;C&#34;)),
      &#34;expectation_vals&#34;: np.ascontiguousarray(np.cumsum(gen_distribution.x.support * gen_distribution.x.pdf_values))}

    self.convgen2 = {
      &#34;min&#34;: gen_distribution.y.min,
      &#34;max&#34;: gen_distribution.y.max,
      &#34;cdf_values&#34;: np.ascontiguousarray(np.copy(gen_distribution.y.cdf_values, order = &#34;C&#34;)),
      &#34;expectation_vals&#34;: np.ascontiguousarray(np.cumsum(gen_distribution.y.support * gen_distribution.y.pdf_values))}

    self.gen_distribution = gen_distribution
    self.MARGIN_BOUND = int(np.iinfo(np.int32).max / 2)

    if season_length is None:
      warnings.warn(&#34;Using length of demand data as season length.&#34;, stacklevel=2)
    self.season_length = len(self.demand_data) if season_length is None else season_length

  def cdf(
    self, 
    x: np.ndarray,
    itc_cap: int = 1000, 
    policy: str = &#34;veto&#34;):
    &#34;&#34;&#34;Evaluates the bivariate post-interconnection power surplus distribution&#39;s cumulative distribution function
    
    Args:
        x (np.ndarray): value at which to evaluate the cdf
        itc_cap (int, optional): interconnection capacity
        policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.

    &#34;&#34;&#34;

    # if x is an n x 2 matrix
    if len(x.shape) == 2 and len(x) &gt; 1:
      return np.array([self.cdf(v,itc_cap,policy) for v in x])

    #bound and unbunble component values
    x = np.clip(x,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    x1, x2 = x.reshape(-1)

    #convgen1, convgen2 = self.gen_distribution.x, self.gen_distribution.y
    n = len(self.net_demand_data)

    cdf = 0

    for k in range(n):
      net_demand1, net_demand2 = self.net_demand_data[k]
      demand1, demand2 = self.demand_data[k]
      point_cdf = C_API.cond_bivariate_power_margin_cdf_py_interface(
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
        np.int32(x1),
        np.int32(x2),
        np.int32(net_demand1),
        np.int32(net_demand2),
        np.int32(demand1),
        np.int32(demand2),
        np.int32(itc_cap),
        np.int32(policy == &#34;share&#34;))

      cdf += point_cdf
    
    return cdf/self.season_length

  def system_lolp(
    self,
    itc_cap: int=1000):
    &#34;&#34;&#34;Computes the system-wide post-interconnection loss of load probability. This is, the probability that at least one area will experience a shortfall.
    
    Args:
        itc_cap (int, optional): Interconnector capacity
    
    &#34;&#34;&#34;
    def trapezoid_prob(ulc,c):

      ulc1, ulc2 = ulc
      return C_API.trapezoid_prob_py_interface(
        np.int32(ulc1),
        np.int32(ulc2),
        np.int32(c),
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data))
      
    n = len(self.net_demand_data)
    gen = self.gen_distribution
    lolp = 0
    
    c = itc_cap
    for k in range(n):
      net_demand1, net_demand2 = self.net_demand_data[k]
      # system-wide lolp does not depend on the policy
      point_lolp = gen.cdf(np.array([net_demand1-c-1,np.Inf])) + gen.cdf(np.array([np.Inf,net_demand2-c-1])) - gen.cdf(np.array([net_demand1+c,net_demand2-c-1])) + trapezoid_prob((net_demand1-c-1,net_demand2+c),2*c)
      lolp += point_lolp

    return lolp/self.season_length


  def lole(
    self,
    itc_cap: int = 1000,
    policy: str = &#34;veto&#34;,
    area: int=0):
    &#34;&#34;&#34;Computes the post-interconnection loss of load expectation.
    
    Args:
        itc_cap (int, optional): interconnection capacity
        policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.
        area (int, optional): Area for which to evaluate LOLE; if area=-1, system-wide lole is returned
    &#34;&#34;&#34;
    if area == -1:
      return len(self.net_demand_data) * self.system_lolp(itc_cap)

    x = np.array([np.Inf,np.Inf])
    x[area] = -1
    #m = (-1,np.Inf)
    lolp = self.cdf(
      x=x, 
      itc_cap=itc_cap,
      policy=policy) 
    
    return self.season_length * lolp


  def swap_axes(self):
    &#34;&#34;&#34;Utility method to flip components in bivariate distribution objects
    &#34;&#34;&#34;
    self.demand_data = np.flip(self.demand_data,axis=1)
    self.renewables_data = np.flip(self.renewables_data,axis=1)
    self.net_demand_data = np.flip(self.net_demand_data,axis=1)
    
    aux = copy.deepcopy(self.convgen1)
    self.convgen1 = copy.deepcopy(self.convgen2)
    self.convgen2 = aux

    self.gen_distribution = Independent(x=self.gen_distribution.y, y=self.gen_distribution.x)
    
  def eeu(
    self,
    itc_cap: int = 1000,
    policy: str = &#34;veto&#34;,
    area: int=0):
    &#34;&#34;&#34;Computes the post-interconnection expected energy unserved.
    
    Args:
        itc_cap (int, optional): interconnection capacity
        policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.
        area (int, optional): Area for which to evaluate eeu; if area=-1, systemwide eeu is returned
    &#34;&#34;&#34;
    
    if area == -1:
      return self.eeu(itc_cap, policy,0) + self.eeu(itc_cap, policy, 1)

    if area == 1:
      self.swap_axes()
    
    n = len(self.net_demand_data)
    eeu = 0

    for k in range(n):
      #print(i)
      net_demand1, net_demand2 = self.net_demand_data[k]
      d1, d2 = self.demand_data[k]
      if policy == &#34;share&#34;:
        point_EPU = C_API.cond_eeu_share_py_interface(
          np.int32(d1),
          np.int32(d2),
          np.int32(net_demand1),
          np.int32(net_demand2),
          np.int32(itc_cap),
          np.int32(self.convgen1[&#34;min&#34;]),
          np.int32(self.convgen2[&#34;min&#34;]),
          np.int32(self.convgen1[&#34;max&#34;]),
          np.int32(self.convgen2[&#34;max&#34;]),
          ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
          ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
          ffi.cast(&#34;double *&#34;,self.convgen1[&#34;expectation_vals&#34;].ctypes.data))
      elif policy == &#34;veto&#34;:
        point_EPU = C_API.cond_eeu_veto_py_interface(
          np.int32(net_demand1),
          np.int32(net_demand2),
          np.int32(itc_cap),
          np.int32(self.convgen1[&#34;min&#34;]),
          np.int32(self.convgen2[&#34;min&#34;]),
          np.int32(self.convgen1[&#34;max&#34;]),
          np.int32(self.convgen2[&#34;max&#34;]),
          ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
          ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
          ffi.cast(&#34;double *&#34;,self.convgen1[&#34;expectation_vals&#34;].ctypes.data))
      else:
        raise ValueError(f&#34;Policy name ({policy}) not recognised.&#34;)

      eeu += point_EPU

    if area == 1:
      self.swap_axes()

    return eeu

  def get_pointwise_risk(self, x: np.ndarray, itc_cap: int = 1000, policy:str = &#34;veto&#34;):
    &#34;&#34;&#34;Calculates the post-interconnection shortfall probability for each one of the net demand observations
    
    Args:
        x (np.ndarray): point to evaluate CDF at
        itc_cap (int, optional): interconnection capacity
        policy (str): one of &#39;veto&#39; or &#39;share&#39;
    
    &#34;&#34;&#34;
    pointwise_cdfs = np.empty((len(self.demand_data),))
    for k, (demand_row, renewables_row) in enumerate(zip(self.demand_data, self.renewables_data)):
      pointwise_cdfs[k] = type(self)(
        demand_data=demand_row.reshape((1,2)),
        renewables_data=renewables_row.reshape((1,2)),
        gen_distribution=self.gen_distribution).cdf(x=x, itc_cap=itc_cap, policy=policy)

    return pointwise_cdfs

  def simulate(self, size: int, itc_cap: int = 1000, policy = &#34;veto&#34;):
    &#34;&#34;&#34;Simulate the post-interconnection bivariate surplus distribution
    
    Args:
        size (int): Sample size
        itc_cap (int, optional): Interconnector capacity
        policy (str): one of &#39;veto&#39; or &#39;share&#39;
    
    &#34;&#34;&#34;
    return self.simulate_region(size, np.array([np.Inf,np.Inf]), itc_cap, policy, False)

  def simulate_region(
    self,
    size: int,
    upper_bounds: np.ndarray,
    itc_cap: int = 1000,
    policy: str = &#34;veto&#34;,
    shortfall_region: bool = False):

    &#34;&#34;&#34;Simulate post-interconnection bivariate surplus distribution conditioned to a rectangular region bounded above.
    
    Args:
        size (int): Sample size
        upper_bounds (np.ndarray): region&#39;s upper bounds
        itc_cap (int, optional): Interconnector capacity
        policy (str): one of &#39;veto&#39; or &#39;share&#39;
        shortfall_region (bool, optional): If True, upper bounds are ignored and the sampling region becomes the shortfall region, this is, min(S_1, S_2) &lt; 0, or equivalently, that in which at least one area has a shortfall.
    
    &#34;&#34;&#34;
    seed = np.random.randint(low=0,high=1e8)
    upper_bounds = np.clip(upper_bounds,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m1, m2 = upper_bounds
    n = len(self.demand_data)

    simulated = np.ascontiguousarray(np.zeros((size,2)),dtype=np.int32)
    #convgen1, convgen2 = self.gen_distribution.x, self.gen_distribution.y
    ### calculate conditional probability of each historical observation conditioned to the region of interest
    if shortfall_region:
      warnings.warn(&#34;Simulating from shortfall region; ignoring passed upper bounds.&#34;, stacklevel=2)
      pointwise_cdfs = self.get_pointwise_risk(x=np.array([0,np.Inf]),itc_cap=itc_cap,policy=policy) + \
        self.get_pointwise_risk(x=np.array([np.Inf,0]),itc_cap=itc_cap,policy=policy) - \
        self.get_pointwise_risk(x=np.array([0,0]),itc_cap=itc_cap,policy=policy) 
      intersection = False
    else:
      pointwise_cdfs = self.get_pointwise_risk(x=upper_bounds,itc_cap=itc_cap,policy=policy)
      intersection = True
    
    # numerical rounding error sometimes output negative probabilities of the order of 1e-30
    pointwise_cdfs = np.clip(pointwise_cdfs, a_min=0.0, a_max=np.Inf)

    total_prob = np.sum(pointwise_cdfs)
    if total_prob &lt;= 1e-8:
      if fixed_area == 1:
        self.swap_axes()
      raise Exception(f&#34;Region has probability {total_prob}; too small to simulate accurately&#34;)
    else:
      probs = pointwise_cdfs/total_prob
      
      samples_per_row = np.random.multinomial(n=size,pvals=probs,size=1).reshape((len(probs),))
      nonzero_samples = samples_per_row &gt; 0
      ## only pass rows which induce at least one simulated value
      row_weights = np.ascontiguousarray(samples_per_row[nonzero_samples],dtype=np.int32)

      net_demand = np.ascontiguousarray(self.net_demand_data[nonzero_samples,:],dtype=np.int32)

      demand = np.ascontiguousarray(self.demand_data[nonzero_samples,:],dtype=np.int32)

      C_API.region_simulation_py_interface(
        np.int32(size),
        ffi.cast(&#34;int *&#34;,simulated.ctypes.data),
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;int *&#34;,net_demand.ctypes.data),
        ffi.cast(&#34;int *&#34;,demand.ctypes.data),
        ffi.cast(&#34;int *&#34;,row_weights.ctypes.data),
        np.int32(net_demand.shape[0]),
        np.int32(m1),
        np.int32(m2),
        np.int32(itc_cap),
        int(seed),
        int(intersection),
        int(policy == &#34;share&#34;))

      return simulated


  def simulate_conditional(
    self,
    size: int,
    fixed_value: int,
    fixed_area: int,
    itc_cap: int = 1000,
    policy: str = &#34;veto&#34;):
    &#34;&#34;&#34;Simulate post-interconnection surplus distribution conditioned to a value in the other area&#39;s surplus
    
    Args:
        size (int): Sample size
        fixed_value (int): Surplus value conditioned on
        fixed_area (TYPE): Area conditioned on
        itc_cap (int, optional): Interconnector capacity
        policy (str): one of &#39;veto&#39; or &#39;share&#39;
    
    &#34;&#34;&#34;
    seed = np.random.randint(low=0,high=1e8)
    m1 = np.clip(fixed_value,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m2 = self.MARGIN_BOUND

    simulated = np.ascontiguousarray(np.zeros((size,2)),dtype=np.int32)
    
    ### calculate conditional probability of each historical observation given
    ### margin value tuple m

    if fixed_area == 0:
      x = np.array([fixed_value,np.Inf])
      y = x - 1
    else:
      x = np.array([np.Inf, fixed_value])
      y = x - 1

    pointwise_cdfs = self.get_pointwise_risk(x=x,itc_cap=itc_cap,policy=policy) - \
      self.get_pointwise_risk(x=y,itc_cap=itc_cap,policy=policy)

    pointwise_cdfs = np.clip(pointwise_cdfs, a_min=0.0, a_max=np.Inf)
  
    ## rounding errors can make probabilities negative of the order of 1e-60
    total_prob = np.sum(pointwise_cdfs)
    
    if total_prob &lt;= 1e-12:
      raise Exception(f&#34;Region has low probability ({total_prob}); too small to simulate accurately&#34;)
    else:
      probs = pointwise_cdfs/total_prob
      
      samples_per_row = np.random.multinomial(n=size,pvals=probs,size=1).reshape((len(probs),))
      nonzero_samples = samples_per_row &gt; 0
      ## only pass rows which induce at least one simulated value
      row_weights = np.ascontiguousarray(samples_per_row[nonzero_samples],dtype=np.int32)

      if fixed_area == 1:
        self.swap_axes()

      net_demand = np.ascontiguousarray(self.net_demand_data[nonzero_samples,:],dtype=np.int32)

      demand = np.ascontiguousarray(self.demand_data[nonzero_samples,:],dtype=np.int32)

      C_API.conditioned_simulation_py_interface(
        np.int32(size),
        ffi.cast(&#34;int *&#34;,simulated.ctypes.data),
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;int *&#34;,net_demand.ctypes.data),
        ffi.cast(&#34;int *&#34;,demand.ctypes.data),
        ffi.cast(&#34;int *&#34;,row_weights.ctypes.data),
        np.int32(net_demand.shape[0]),
        np.int32(m1),
        np.int32(itc_cap),
        int(seed),
        int(policy == &#34;share&#34;))

      if fixed_area == 1:
        self.swap_axes()

    return simulated[:,1] #first column has variable conditioned on (constant value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="riskmodels.powersys.iid.surplus.BaseSurplus" href="#riskmodels.powersys.iid.surplus.BaseSurplus">BaseSurplus</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, x:Â np.ndarray, itc_cap:Â intÂ =Â 1000, policy:Â strÂ =Â 'veto')</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluates the bivariate post-interconnection power surplus distribution's cumulative distribution function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>value at which to evaluate the cdf</dd>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>interconnection capacity</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>one of 'veto' or 'share'; in a 'veto' policy, areas only export spare available capacity, while in a 'share' policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(
  self, 
  x: np.ndarray,
  itc_cap: int = 1000, 
  policy: str = &#34;veto&#34;):
  &#34;&#34;&#34;Evaluates the bivariate post-interconnection power surplus distribution&#39;s cumulative distribution function
  
  Args:
      x (np.ndarray): value at which to evaluate the cdf
      itc_cap (int, optional): interconnection capacity
      policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.

  &#34;&#34;&#34;

  # if x is an n x 2 matrix
  if len(x.shape) == 2 and len(x) &gt; 1:
    return np.array([self.cdf(v,itc_cap,policy) for v in x])

  #bound and unbunble component values
  x = np.clip(x,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
  x1, x2 = x.reshape(-1)

  #convgen1, convgen2 = self.gen_distribution.x, self.gen_distribution.y
  n = len(self.net_demand_data)

  cdf = 0

  for k in range(n):
    net_demand1, net_demand2 = self.net_demand_data[k]
    demand1, demand2 = self.demand_data[k]
    point_cdf = C_API.cond_bivariate_power_margin_cdf_py_interface(
      np.int32(self.convgen1[&#34;min&#34;]),
      np.int32(self.convgen2[&#34;min&#34;]),
      np.int32(self.convgen1[&#34;max&#34;]),
      np.int32(self.convgen2[&#34;max&#34;]),
      ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
      ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
      np.int32(x1),
      np.int32(x2),
      np.int32(net_demand1),
      np.int32(net_demand2),
      np.int32(demand1),
      np.int32(demand2),
      np.int32(itc_cap),
      np.int32(policy == &#34;share&#34;))

    cdf += point_cdf
  
  return cdf/self.season_length</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.eeu"><code class="name flex">
<span>def <span class="ident">eeu</span></span>(<span>self, itc_cap:Â intÂ =Â 1000, policy:Â strÂ =Â 'veto', area:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the post-interconnection expected energy unserved.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>interconnection capacity</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>one of 'veto' or 'share'; in a 'veto' policy, areas only export spare available capacity, while in a 'share' policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Area for which to evaluate eeu; if area=-1, systemwide eeu is returned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eeu(
  self,
  itc_cap: int = 1000,
  policy: str = &#34;veto&#34;,
  area: int=0):
  &#34;&#34;&#34;Computes the post-interconnection expected energy unserved.
  
  Args:
      itc_cap (int, optional): interconnection capacity
      policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.
      area (int, optional): Area for which to evaluate eeu; if area=-1, systemwide eeu is returned
  &#34;&#34;&#34;
  
  if area == -1:
    return self.eeu(itc_cap, policy,0) + self.eeu(itc_cap, policy, 1)

  if area == 1:
    self.swap_axes()
  
  n = len(self.net_demand_data)
  eeu = 0

  for k in range(n):
    #print(i)
    net_demand1, net_demand2 = self.net_demand_data[k]
    d1, d2 = self.demand_data[k]
    if policy == &#34;share&#34;:
      point_EPU = C_API.cond_eeu_share_py_interface(
        np.int32(d1),
        np.int32(d2),
        np.int32(net_demand1),
        np.int32(net_demand2),
        np.int32(itc_cap),
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;expectation_vals&#34;].ctypes.data))
    elif policy == &#34;veto&#34;:
      point_EPU = C_API.cond_eeu_veto_py_interface(
        np.int32(net_demand1),
        np.int32(net_demand2),
        np.int32(itc_cap),
        np.int32(self.convgen1[&#34;min&#34;]),
        np.int32(self.convgen2[&#34;min&#34;]),
        np.int32(self.convgen1[&#34;max&#34;]),
        np.int32(self.convgen2[&#34;max&#34;]),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
        ffi.cast(&#34;double *&#34;,self.convgen1[&#34;expectation_vals&#34;].ctypes.data))
    else:
      raise ValueError(f&#34;Policy name ({policy}) not recognised.&#34;)

    eeu += point_EPU

  if area == 1:
    self.swap_axes()

  return eeu</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.get_pointwise_risk"><code class="name flex">
<span>def <span class="ident">get_pointwise_risk</span></span>(<span>self, x:Â np.ndarray, itc_cap:Â intÂ =Â 1000, policy:Â strÂ =Â 'veto')</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the post-interconnection shortfall probability for each one of the net demand observations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>point to evaluate CDF at</dd>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>interconnection capacity</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>str</code></dt>
<dd>one of 'veto' or 'share'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pointwise_risk(self, x: np.ndarray, itc_cap: int = 1000, policy:str = &#34;veto&#34;):
  &#34;&#34;&#34;Calculates the post-interconnection shortfall probability for each one of the net demand observations
  
  Args:
      x (np.ndarray): point to evaluate CDF at
      itc_cap (int, optional): interconnection capacity
      policy (str): one of &#39;veto&#39; or &#39;share&#39;
  
  &#34;&#34;&#34;
  pointwise_cdfs = np.empty((len(self.demand_data),))
  for k, (demand_row, renewables_row) in enumerate(zip(self.demand_data, self.renewables_data)):
    pointwise_cdfs[k] = type(self)(
      demand_data=demand_row.reshape((1,2)),
      renewables_data=renewables_row.reshape((1,2)),
      gen_distribution=self.gen_distribution).cdf(x=x, itc_cap=itc_cap, policy=policy)

  return pointwise_cdfs</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.lole"><code class="name flex">
<span>def <span class="ident">lole</span></span>(<span>self, itc_cap:Â intÂ =Â 1000, policy:Â strÂ =Â 'veto', area:Â intÂ =Â 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the post-interconnection loss of load expectation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>interconnection capacity</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>one of 'veto' or 'share'; in a 'veto' policy, areas only export spare available capacity, while in a 'share' policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.</dd>
<dt><strong><code>area</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Area for which to evaluate LOLE; if area=-1, system-wide lole is returned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lole(
  self,
  itc_cap: int = 1000,
  policy: str = &#34;veto&#34;,
  area: int=0):
  &#34;&#34;&#34;Computes the post-interconnection loss of load expectation.
  
  Args:
      itc_cap (int, optional): interconnection capacity
      policy (str, optional): one of &#39;veto&#39; or &#39;share&#39;; in a &#39;veto&#39; policy, areas only export spare available capacity, while in a &#39;share&#39; policy, exports are market-driven, i.e., by power scarcity at both areas. Shortfalls can extend from one area to another by diverting power.
      area (int, optional): Area for which to evaluate LOLE; if area=-1, system-wide lole is returned
  &#34;&#34;&#34;
  if area == -1:
    return len(self.net_demand_data) * self.system_lolp(itc_cap)

  x = np.array([np.Inf,np.Inf])
  x[area] = -1
  #m = (-1,np.Inf)
  lolp = self.cdf(
    x=x, 
    itc_cap=itc_cap,
    policy=policy) 
  
  return self.season_length * lolp</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, size:Â int, itc_cap:Â intÂ =Â 1000, policy='veto')</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate the post-interconnection bivariate surplus distribution</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Sample size</dd>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnector capacity</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>str</code></dt>
<dd>one of 'veto' or 'share'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, size: int, itc_cap: int = 1000, policy = &#34;veto&#34;):
  &#34;&#34;&#34;Simulate the post-interconnection bivariate surplus distribution
  
  Args:
      size (int): Sample size
      itc_cap (int, optional): Interconnector capacity
      policy (str): one of &#39;veto&#39; or &#39;share&#39;
  
  &#34;&#34;&#34;
  return self.simulate_region(size, np.array([np.Inf,np.Inf]), itc_cap, policy, False)</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate_conditional"><code class="name flex">
<span>def <span class="ident">simulate_conditional</span></span>(<span>self, size:Â int, fixed_value:Â int, fixed_area:Â int, itc_cap:Â intÂ =Â 1000, policy:Â strÂ =Â 'veto')</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate post-interconnection surplus distribution conditioned to a value in the other area's surplus</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Sample size</dd>
<dt><strong><code>fixed_value</code></strong> :&ensp;<code>int</code></dt>
<dd>Surplus value conditioned on</dd>
<dt><strong><code>fixed_area</code></strong> :&ensp;<code>TYPE</code></dt>
<dd>Area conditioned on</dd>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnector capacity</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>str</code></dt>
<dd>one of 'veto' or 'share'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_conditional(
  self,
  size: int,
  fixed_value: int,
  fixed_area: int,
  itc_cap: int = 1000,
  policy: str = &#34;veto&#34;):
  &#34;&#34;&#34;Simulate post-interconnection surplus distribution conditioned to a value in the other area&#39;s surplus
  
  Args:
      size (int): Sample size
      fixed_value (int): Surplus value conditioned on
      fixed_area (TYPE): Area conditioned on
      itc_cap (int, optional): Interconnector capacity
      policy (str): one of &#39;veto&#39; or &#39;share&#39;
  
  &#34;&#34;&#34;
  seed = np.random.randint(low=0,high=1e8)
  m1 = np.clip(fixed_value,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
  m2 = self.MARGIN_BOUND

  simulated = np.ascontiguousarray(np.zeros((size,2)),dtype=np.int32)
  
  ### calculate conditional probability of each historical observation given
  ### margin value tuple m

  if fixed_area == 0:
    x = np.array([fixed_value,np.Inf])
    y = x - 1
  else:
    x = np.array([np.Inf, fixed_value])
    y = x - 1

  pointwise_cdfs = self.get_pointwise_risk(x=x,itc_cap=itc_cap,policy=policy) - \
    self.get_pointwise_risk(x=y,itc_cap=itc_cap,policy=policy)

  pointwise_cdfs = np.clip(pointwise_cdfs, a_min=0.0, a_max=np.Inf)

  ## rounding errors can make probabilities negative of the order of 1e-60
  total_prob = np.sum(pointwise_cdfs)
  
  if total_prob &lt;= 1e-12:
    raise Exception(f&#34;Region has low probability ({total_prob}); too small to simulate accurately&#34;)
  else:
    probs = pointwise_cdfs/total_prob
    
    samples_per_row = np.random.multinomial(n=size,pvals=probs,size=1).reshape((len(probs),))
    nonzero_samples = samples_per_row &gt; 0
    ## only pass rows which induce at least one simulated value
    row_weights = np.ascontiguousarray(samples_per_row[nonzero_samples],dtype=np.int32)

    if fixed_area == 1:
      self.swap_axes()

    net_demand = np.ascontiguousarray(self.net_demand_data[nonzero_samples,:],dtype=np.int32)

    demand = np.ascontiguousarray(self.demand_data[nonzero_samples,:],dtype=np.int32)

    C_API.conditioned_simulation_py_interface(
      np.int32(size),
      ffi.cast(&#34;int *&#34;,simulated.ctypes.data),
      np.int32(self.convgen1[&#34;min&#34;]),
      np.int32(self.convgen2[&#34;min&#34;]),
      np.int32(self.convgen1[&#34;max&#34;]),
      np.int32(self.convgen2[&#34;max&#34;]),
      ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
      ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
      ffi.cast(&#34;int *&#34;,net_demand.ctypes.data),
      ffi.cast(&#34;int *&#34;,demand.ctypes.data),
      ffi.cast(&#34;int *&#34;,row_weights.ctypes.data),
      np.int32(net_demand.shape[0]),
      np.int32(m1),
      np.int32(itc_cap),
      int(seed),
      int(policy == &#34;share&#34;))

    if fixed_area == 1:
      self.swap_axes()

  return simulated[:,1] #first column has variable conditioned on (constant value)</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate_region"><code class="name flex">
<span>def <span class="ident">simulate_region</span></span>(<span>self, size:Â int, upper_bounds:Â np.ndarray, itc_cap:Â intÂ =Â 1000, policy:Â strÂ =Â 'veto', shortfall_region:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate post-interconnection bivariate surplus distribution conditioned to a rectangular region bounded above.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>int</code></dt>
<dd>Sample size</dd>
<dt><strong><code>upper_bounds</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>region's upper bounds</dd>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnector capacity</dd>
<dt><strong><code>policy</code></strong> :&ensp;<code>str</code></dt>
<dd>one of 'veto' or 'share'</dd>
<dt><strong><code>shortfall_region</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, upper bounds are ignored and the sampling region becomes the shortfall region, this is, min(S_1, S_2) &lt; 0, or equivalently, that in which at least one area has a shortfall.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_region(
  self,
  size: int,
  upper_bounds: np.ndarray,
  itc_cap: int = 1000,
  policy: str = &#34;veto&#34;,
  shortfall_region: bool = False):

  &#34;&#34;&#34;Simulate post-interconnection bivariate surplus distribution conditioned to a rectangular region bounded above.
  
  Args:
      size (int): Sample size
      upper_bounds (np.ndarray): region&#39;s upper bounds
      itc_cap (int, optional): Interconnector capacity
      policy (str): one of &#39;veto&#39; or &#39;share&#39;
      shortfall_region (bool, optional): If True, upper bounds are ignored and the sampling region becomes the shortfall region, this is, min(S_1, S_2) &lt; 0, or equivalently, that in which at least one area has a shortfall.
  
  &#34;&#34;&#34;
  seed = np.random.randint(low=0,high=1e8)
  upper_bounds = np.clip(upper_bounds,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
  m1, m2 = upper_bounds
  n = len(self.demand_data)

  simulated = np.ascontiguousarray(np.zeros((size,2)),dtype=np.int32)
  #convgen1, convgen2 = self.gen_distribution.x, self.gen_distribution.y
  ### calculate conditional probability of each historical observation conditioned to the region of interest
  if shortfall_region:
    warnings.warn(&#34;Simulating from shortfall region; ignoring passed upper bounds.&#34;, stacklevel=2)
    pointwise_cdfs = self.get_pointwise_risk(x=np.array([0,np.Inf]),itc_cap=itc_cap,policy=policy) + \
      self.get_pointwise_risk(x=np.array([np.Inf,0]),itc_cap=itc_cap,policy=policy) - \
      self.get_pointwise_risk(x=np.array([0,0]),itc_cap=itc_cap,policy=policy) 
    intersection = False
  else:
    pointwise_cdfs = self.get_pointwise_risk(x=upper_bounds,itc_cap=itc_cap,policy=policy)
    intersection = True
  
  # numerical rounding error sometimes output negative probabilities of the order of 1e-30
  pointwise_cdfs = np.clip(pointwise_cdfs, a_min=0.0, a_max=np.Inf)

  total_prob = np.sum(pointwise_cdfs)
  if total_prob &lt;= 1e-8:
    if fixed_area == 1:
      self.swap_axes()
    raise Exception(f&#34;Region has probability {total_prob}; too small to simulate accurately&#34;)
  else:
    probs = pointwise_cdfs/total_prob
    
    samples_per_row = np.random.multinomial(n=size,pvals=probs,size=1).reshape((len(probs),))
    nonzero_samples = samples_per_row &gt; 0
    ## only pass rows which induce at least one simulated value
    row_weights = np.ascontiguousarray(samples_per_row[nonzero_samples],dtype=np.int32)

    net_demand = np.ascontiguousarray(self.net_demand_data[nonzero_samples,:],dtype=np.int32)

    demand = np.ascontiguousarray(self.demand_data[nonzero_samples,:],dtype=np.int32)

    C_API.region_simulation_py_interface(
      np.int32(size),
      ffi.cast(&#34;int *&#34;,simulated.ctypes.data),
      np.int32(self.convgen1[&#34;min&#34;]),
      np.int32(self.convgen2[&#34;min&#34;]),
      np.int32(self.convgen1[&#34;max&#34;]),
      np.int32(self.convgen2[&#34;max&#34;]),
      ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
      ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data),
      ffi.cast(&#34;int *&#34;,net_demand.ctypes.data),
      ffi.cast(&#34;int *&#34;,demand.ctypes.data),
      ffi.cast(&#34;int *&#34;,row_weights.ctypes.data),
      np.int32(net_demand.shape[0]),
      np.int32(m1),
      np.int32(m2),
      np.int32(itc_cap),
      int(seed),
      int(intersection),
      int(policy == &#34;share&#34;))

    return simulated</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.swap_axes"><code class="name flex">
<span>def <span class="ident">swap_axes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Utility method to flip components in bivariate distribution objects</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swap_axes(self):
  &#34;&#34;&#34;Utility method to flip components in bivariate distribution objects
  &#34;&#34;&#34;
  self.demand_data = np.flip(self.demand_data,axis=1)
  self.renewables_data = np.flip(self.renewables_data,axis=1)
  self.net_demand_data = np.flip(self.net_demand_data,axis=1)
  
  aux = copy.deepcopy(self.convgen1)
  self.convgen1 = copy.deepcopy(self.convgen2)
  self.convgen2 = aux

  self.gen_distribution = Independent(x=self.gen_distribution.y, y=self.gen_distribution.x)</code></pre>
</details>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateEmpirical.system_lolp"><code class="name flex">
<span>def <span class="ident">system_lolp</span></span>(<span>self, itc_cap:Â intÂ =Â 1000)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the system-wide post-interconnection loss of load probability. This is, the probability that at least one area will experience a shortfall.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>itc_cap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Interconnector capacity</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_lolp(
  self,
  itc_cap: int=1000):
  &#34;&#34;&#34;Computes the system-wide post-interconnection loss of load probability. This is, the probability that at least one area will experience a shortfall.
  
  Args:
      itc_cap (int, optional): Interconnector capacity
  
  &#34;&#34;&#34;
  def trapezoid_prob(ulc,c):

    ulc1, ulc2 = ulc
    return C_API.trapezoid_prob_py_interface(
      np.int32(ulc1),
      np.int32(ulc2),
      np.int32(c),
      np.int32(self.convgen1[&#34;min&#34;]),
      np.int32(self.convgen2[&#34;min&#34;]),
      np.int32(self.convgen1[&#34;max&#34;]),
      np.int32(self.convgen2[&#34;max&#34;]),
      ffi.cast(&#34;double *&#34;,self.convgen1[&#34;cdf_values&#34;].ctypes.data),
      ffi.cast(&#34;double *&#34;,self.convgen2[&#34;cdf_values&#34;].ctypes.data))
    
  n = len(self.net_demand_data)
  gen = self.gen_distribution
  lolp = 0
  
  c = itc_cap
  for k in range(n):
    net_demand1, net_demand2 = self.net_demand_data[k]
    # system-wide lolp does not depend on the policy
    point_lolp = gen.cdf(np.array([net_demand1-c-1,np.Inf])) + gen.cdf(np.array([np.Inf,net_demand2-c-1])) - gen.cdf(np.array([net_demand1+c,net_demand2-c-1])) + trapezoid_prob((net_demand1-c-1,net_demand2+c),2*c)
    lolp += point_lolp

  return lolp/self.season_length</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateMonteCarlo"><code class="flex name class">
<span>class <span class="ident">BivariateMonteCarlo</span></span>
<span>(</span><span>**data:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>General bivariate power surplus distribution formed by a power generation distribution and a net demand distribution. It calculates risk metrics by simulation and only implements a veto policy between areas, this is, areas will only export spare available capacity. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gen_distribution</code></strong> :&ensp;<code>BaseDistribution</code></dt>
<dd>available conventional generation distribution</dd>
<dt><strong><code>net_demand</code></strong> :&ensp;<code>BaseDistribution</code></dt>
<dd>net demand distribution</dd>
<dt><strong><code>size</code></strong> :&ensp;<code>BaseDistribution</code></dt>
<dd>Sample size for Monte Carlo estimation</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises ValidationError if the input data cannot be parsed to form a valid model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BivariateMonteCarlo(BaseBivariateMonteCarlo):

  &#34;&#34;&#34;General bivariate power surplus distribution formed by a power generation distribution and a net demand distribution. It calculates risk metrics by simulation and only implements a veto policy between areas, this is, areas will only export spare available capacity. 
  
  Args:
      gen_distribution (BaseDistribution): available conventional generation distribution
      net_demand (BaseDistribution): net demand distribution
      size (BaseDistribution): Sample size for Monte Carlo estimation
      
  &#34;&#34;&#34;

  gen_distribution: BaseDistribution
  net_demand: BaseDistribution
  size: int

  class Config:
    arbitrary_types_allowed = True

  def get_pre_itc_sample(self) -&gt; np.ndarray:
    &#34;&#34;&#34;Returns a pre-interconnection surplus sample by simulating the passed bivariate distributions for available conventional generation and net demand
    
    Returns:
        np.ndarray: Sample
    &#34;&#34;&#34;
    return self.gen_distribution.simulate(self.size) - self.net_demand.simulate(self.size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo">BaseBivariateMonteCarlo</a></li>
<li>pydantic.main.BaseModel</li>
<li>pydantic.utils.Representation</li>
<li><a title="riskmodels.powersys.iid.surplus.BaseSurplus" href="#riskmodels.powersys.iid.surplus.BaseSurplus">BaseSurplus</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.Config"><code class="name">var <span class="ident">Config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.gen_distribution"><code class="name">var <span class="ident">gen_distribution</span> :Â <a title="riskmodels.bivariate.BaseDistribution" href="../../bivariate.html#riskmodels.bivariate.BaseDistribution">BaseDistribution</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.net_demand"><code class="name">var <span class="ident">net_demand</span> :Â <a title="riskmodels.bivariate.BaseDistribution" href="../../bivariate.html#riskmodels.bivariate.BaseDistribution">BaseDistribution</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.size"><code class="name">var <span class="ident">size</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.get_pre_itc_sample"><code class="name flex">
<span>def <span class="ident">get_pre_itc_sample</span></span>(<span>self) â€‘>Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a pre-interconnection surplus sample by simulating the passed bivariate distributions for available conventional generation and net demand</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Sample</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pre_itc_sample(self) -&gt; np.ndarray:
  &#34;&#34;&#34;Returns a pre-interconnection surplus sample by simulating the passed bivariate distributions for available conventional generation and net demand
  
  Returns:
      np.ndarray: Sample
  &#34;&#34;&#34;
  return self.gen_distribution.simulate(self.size) - self.net_demand.simulate(self.size)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo">BaseBivariateMonteCarlo</a></b></code>:
<ul class="hlist">
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.cdf" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.cdf">cdf</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.eeu" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.eeu">eeu</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.itc_flow" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.itc_flow">itc_flow</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.lole" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.lole">lole</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.simulate" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.simulate">simulate</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="riskmodels.powersys.iid" href="index.html">riskmodels.powersys.iid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo">BaseBivariateMonteCarlo</a></code></h4>
<ul class="two-column">
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.cdf" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.cdf">cdf</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.eeu" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.eeu">eeu</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.get_pre_itc_sample" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.get_pre_itc_sample">get_pre_itc_sample</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.itc_flow" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.itc_flow">itc_flow</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.lole" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.lole">lole</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.season_length" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.season_length">season_length</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.simulate" href="#riskmodels.powersys.iid.surplus.BaseBivariateMonteCarlo.simulate">simulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="riskmodels.powersys.iid.surplus.BaseSurplus" href="#riskmodels.powersys.iid.surplus.BaseSurplus">BaseSurplus</a></code></h4>
<ul class="">
<li><code><a title="riskmodels.powersys.iid.surplus.BaseSurplus.cdf" href="#riskmodels.powersys.iid.surplus.BaseSurplus.cdf">cdf</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseSurplus.eeu" href="#riskmodels.powersys.iid.surplus.BaseSurplus.eeu">eeu</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseSurplus.lole" href="#riskmodels.powersys.iid.surplus.BaseSurplus.lole">lole</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BaseSurplus.simulate" href="#riskmodels.powersys.iid.surplus.BaseSurplus.simulate">simulate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical">BivariateEmpirical</a></code></h4>
<ul class="">
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.cdf" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.cdf">cdf</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.eeu" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.eeu">eeu</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.get_pointwise_risk" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.get_pointwise_risk">get_pointwise_risk</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.lole" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.lole">lole</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate">simulate</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate_conditional" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate_conditional">simulate_conditional</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate_region" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.simulate_region">simulate_region</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.swap_axes" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.swap_axes">swap_axes</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateEmpirical.system_lolp" href="#riskmodels.powersys.iid.surplus.BivariateEmpirical.system_lolp">system_lolp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="riskmodels.powersys.iid.surplus.BivariateMonteCarlo" href="#riskmodels.powersys.iid.surplus.BivariateMonteCarlo">BivariateMonteCarlo</a></code></h4>
<ul class="">
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.Config" href="#riskmodels.powersys.iid.surplus.BivariateMonteCarlo.Config">Config</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.gen_distribution" href="#riskmodels.powersys.iid.surplus.BivariateMonteCarlo.gen_distribution">gen_distribution</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.get_pre_itc_sample" href="#riskmodels.powersys.iid.surplus.BivariateMonteCarlo.get_pre_itc_sample">get_pre_itc_sample</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.net_demand" href="#riskmodels.powersys.iid.surplus.BivariateMonteCarlo.net_demand">net_demand</a></code></li>
<li><code><a title="riskmodels.powersys.iid.surplus.BivariateMonteCarlo.size" href="#riskmodels.powersys.iid.surplus.BivariateMonteCarlo.size">size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>